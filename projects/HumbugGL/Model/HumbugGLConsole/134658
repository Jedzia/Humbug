format 76
"main" // HumbugGL::main
  revision 61
  modified_by 2 "root"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default class_drawing_mode default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  cpp_h_dir "Crunchy/"
  cpp_src_dir "Crunchy/"
  cpp_namespace "CRUNCHY_NAMESPACE"
  oid 134658
  classview 134658 "CrZip"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default class_drawing_mode default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    associated_deployment_view deploymentview_ref 167298 // CrZip
    oid 134658
    class 243586 "CrZipFileInfo"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 243586
      comment "! Information about a file inside archive.
! Call CrZip::getCurrentFileInfo() or CrZipFile::getFileInfo() to
! fill this structure. "
      attribute 171906 "name"
	public explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 171906
	comment "/ File name."
      end

      attribute 172034 "versionCreated"
	public explicit_type "uint16_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 172034
	comment "/ Version created by."
      end

      attribute 172162 "versionNeeded"
	public explicit_type "uint16_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 172162
	comment "/ Version needed to extract."
      end

      attribute 172290 "flags"
	public explicit_type "uint16_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 172290
	comment "/ General purpose flags."
      end

      attribute 172418 "method"
	public explicit_type "uint16_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 172418
	comment "/ Compression method."
      end

      attribute 172546 "dateTime"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 172546
	comment "/ Last modification date and time."
      end

      attribute 172674 "crc"
	public explicit_type "uint32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 172674
	comment "/ CRC."
      end

      attribute 172802 "compressedSize"
	public explicit_type "uint32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 172802
	comment "/ Compressed file size."
      end

      attribute 172930 "uncompressedSize"
	public explicit_type "uint32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 172930
	comment "/ Uncompressed file size."
      end

      attribute 173058 "diskNumberStart"
	public explicit_type "uint16_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 173058
	comment "/ Disk number start."
      end

      attribute 173186 "internalAttr"
	public explicit_type "uint16_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 173186
	comment "/ Internal file attributes."
      end

      attribute 173314 "externalAttr"
	public explicit_type "uint32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 173314
	comment "/ External file attributes."
      end

      attribute 173442 "comment"
	public explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 173442
	comment "/ Comment."
      end

      attribute 173570 "extra"
	public explicit_type "byte"
	stereotype "vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 173570
	comment "/ Extra field."
      end
    end

    class 236034 "CrZipPrivate"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 236034
      classrelation 189570 // <dependency>
	relation 189570 -_->
	  stereotype "friend"
	  oid 189570
	  a default
	    cpp default "${type}"
	    classrelation_ref 189570 // <dependency>
	  b parent class_ref 236674 // CrZip
	oid 189570
      end

      classrelation 236802 // <dependency>
	relation 236802 -_->
	  stereotype "friend"
	  oid 236802
	  a package
	    cpp default "${type}"
	    classrelation_ref 236802 // <dependency>
	  b parent class_ref 298754 // CrZipBase
	oid 236802
      end

      operation 200322 "CrZipPrivate"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)} : 
fileNameCodec(0),
    commentCodec(0),
    ioDevice(NULL),
    mode(CrZipBase::mdNotOpen),
    hasCurrentFile_f(false),
    zipError(UNZ_OK) ${throw}{
  ${body}}
"
	
	
	
	
	oid 200322
      end

      operation 200578 "CrZipPrivate"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param in name "zipName" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}const ${t0} & ${p0}${)} :
fileNameCodec(0),
    commentCodec(0),
    zipName(zipName),
    ioDevice(NULL),
    mode(CrZipBase::mdNotOpen),
    hasCurrentFile_f(false),
    zipError(UNZ_OK) ${throw}{
  ${body}}
"
	
	
	
	
	oid 200578
      end

      operation 200706 "CrZipPrivate"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param in name "zipName" type class_ref 278274 // CrIODevice
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}const ${t0} & ${p0}${)} :
fileNameCodec(0),
    commentCodec(0),
    ioDevice(ioDevice),
    mode(CrZipBase::mdNotOpen),
    hasCurrentFile_f(false),
    zipError(UNZ_OK) ${throw}{
  ${body}}
"
	
	
	
	
	oid 200706
      end

      operation 200450 "~CrZipPrivate"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
	oid 200450
      end

      attribute 186626 "hasCurrentFile_f"
	public explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 186626
      end

      attribute 180098 "zipError"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 180098
      end

      attribute 164098 "fileNameCodec"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 164098
      end

      attribute 164226 "commentCodec"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 164226
      end

      attribute 162178 "zipName"
	public explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 162178
      end

      attribute 162306 "ioDevice"
	public type class_ref 278274 // CrIODevice
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 162306
      end

      attribute 162434 "comment"
	public explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 162434
      end

      attribute 162690 "unzFile_f"
	public explicit_type "unzFile"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 162690
      end

      attribute 162818 "zipFile_f"
	public explicit_type "zipFile"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 162818
      end

      classrelation 176514 // mode (<directional composition>)
	relation 176514 *-->
	  oid 176514
	  a role_name "mode" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 176514 // mode (<directional composition>)
	  b parent class_ref 236930 // Mode
	oid 176514
      end
    end

    class 298754 "CrZipBase"
      abstract visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 298754
      comment "!ZIP archive.
!\\class CrZip CrZip.h <quazip/quazip.h>
! This class implements basic interface to the ZIP archive. It can be
! used to read table contents of the ZIP archive and retreiving
! information about the files inside it.
!
! You can also use this class to open files inside archive by passing
! pointer to the instance of this class to the constructor of the
! CrZipFile class. But see CrZipFile::CrZipFile(CrZip*, QObject*)
! for the possible pitfalls.
!
! This class is indended to provide interface to the ZIP subpackage of
! the ZIP/UNZIP package as well as to the UNZIP subpackage. But
! currently it supports only UNZIP.
!
! The use of this class is simple - just create instance using
! constructor, then set ZIP archive file name using setFile() function
! (if you did not passed the name to the constructor), then open() and
! then use different functions to work with it! Well, if you are
! paranoid, you may also wish to call close before destructing the
! instance, to check for errors on close.
!
! You may also use getUnzFile() and getZipFile() functions to get the
! ZIP archive handle and use it with ZIP/UNZIP package API directly.
!
! This class supports localized file names inside ZIP archive, but you
! have to set up proper codec with setCodec() function. By default,
! locale codec will be used, which is probably ok for UNIX systems, but
! will almost certainly fail with ZIP archives created in Windows. This
! is because Windows ZIP programs have strange habit of using DOS
! encoding for file names in ZIP archives. For example, ZIP archive
! with cyrillic names created in Windows will have file names in \\c
! IBM866 encoding instead of \\c WINDOWS-1251. I think that calling one
! function is not much trouble, but for true platform independency it
! would be nice to have some mechanism for file name encoding auto
! detection using locale information. Does anyone know a good way to do
! it?"
      classrelation 236546 // <dependency>
	relation 236546 -_->
	  stereotype "friend"
	  oid 236546
	  a default
	    cpp default "${type}"
	    classrelation_ref 236546 // <dependency>
	  b parent class_ref 236034 // CrZipPrivate
	oid 236546
      end

      class 237058 "CaseSensitivity"
	visibility package stereotype "enum"
	cpp_decl "${comment}enum ${name} {
${items}
};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	oid 237058
	comment "/ Case sensitivity for the file names.
/ This is what you specify when accessing files in the archive.
/ Works perfectly fine with any characters thanks to Qt's great
/ unicode support. This is different from ZIP/UNZIP API, where
/ only US-ASCII characters was supported.
"
	attribute 165122 "csDefault"
	  public type class_ref 237058 // CaseSensitivity
	  init_value "0"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 165122
	  comment "/< Default for platform. Case sensitive for UNIX, not for Windows."
	end

	attribute 165250 "csSensitive"
	  public type class_ref 237058 // CaseSensitivity
	  init_value "1"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 165250
	  comment "/< Case sensitive."
	end

	attribute 165378 "csInsensitive"
	  public type class_ref 237058 // CaseSensitivity
	  init_value "2 ///< Case insensitive.
    "
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 165378
	  comment "/< Case insensitive."
	end
      end

      class 236802 "Constants"
	visibility package stereotype "enum"
	cpp_decl "${comment}enum ${name} {
${items}
};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	oid 236802
	comment "/ Useful constants."
	attribute 164354 "MAX_FILE_NAME_LENGTH"
	  public type class_ref 236802 // Constants
	  init_value "256 /**< Maximum file name length. Taken from
                                 \\c UNZ_MAXFILENAMEINZIP constant in
                                 unzip.c. */
    "
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 164354
	  comment "/< Maximum file name length. Taken from \\c UNZ_MAXFILENAMEINZIP constant in unzip.c."
	end
      end

      class 236930 "Mode"
	visibility package stereotype "enum"
	cpp_decl "${comment}enum ${name} {
${items}
};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	oid 236930
	comment "/ Open mode of the ZIP file."
	attribute 164482 "mdNotOpen"
	  public type class_ref 236930 // Mode
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 164482
	  comment "/< ZIP file is not open. This is the initial mode."
	end

	attribute 164610 "mdUnzip"
	  public type class_ref 236930 // Mode
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 164610
	  comment "/< ZIP file is open for reading files inside it."
	end

	attribute 164738 "mdCreate"
	  public type class_ref 236930 // Mode
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 164738
	  comment "/< ZIP file was created with open() call."
	end

	attribute 164866 "mdAppend"
	  public type class_ref 236930 // Mode
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 164866
	  comment "/< ZIP file was created with open() call.
/< ZIP file was opened in append mode. This refers to
/ \\c APPEND_STATUS_CREATEAFTER mode in ZIP/UNZIP package
/ and means that zip is appended to some existing file
/ what is useful when that file contains
/ self-extractor code. This is obviously \\em not what
/ you whant to use to add files to the existing ZIP
/ archive."
	end

	attribute 164994 "mdAdd"
	  public type class_ref 236930 // Mode
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 164994
	  comment "/< ZIP file was opened for adding files in the archive."
	end
      end

      operation 286338 "CrZipBase"
	private explicit_return_type ""
	nparams 1
	  param in name "that" type class_ref 298754 // CrZipBase
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	
	
	
	
	oid 286338
	comment "! not (and will not be) implemented"
      end

      operation 286466 "operator ="
	private return_type class_ref 298754 // CrZipBase
	nparams 1
	  param in name "that" type class_ref 298754 // CrZipBase
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 286466
	comment "! not (and will not be) implemented"
      end

      operation 286594 "CrZipBase"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "//*
// * / Constructs CrZip object.
// * * Call setName() before opening constructed object.

${inline}${class}::${name}${(}${)}:
  p(new CrZipPrivate())
${throw}{
  ${body}}
"
	
	
	
	
	oid 286594
	comment "! Constructs CrZip object.
! Call setName() before opening constructed object. "
      end

      operation 286722 "CrZipBase"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param in name "zipName" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}${)}:
  p(new CrZipPrivate(zipName))
${throw}{
  ${body}}
"
	
	
	
	
	oid 286722
	comment "! Constructs CrZip object associated with ZIP file \\a zipName."
      end

      operation 286850 "CrZipBase"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "ioDevice" type class_ref 278274 // CrIODevice
	cpp_decl "    ${comment}${inline}${name}${(}${t0} & ${p0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} & ${p0}${)}:
  p(new CrZipPrivate(ioDevice))
${throw}{
  ${body}}
"
	
	
	
	
	oid 286850
	comment "! Constructs CrZip object associated with ZIP file represented by \\a ioDevice.
! The IO device must be seekable, otherwise an error will occur when opening. "
      end

      operation 286978 "~CrZipBase"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
	oid 286978
	comment "! Destroys CrZip object.
! Calls close() if necessary. "
      end

      operation 287106 "open"
	abstract preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 2
	  param in name "mode" type class_ref 236930 // Mode
	  param inout name "ioApi" explicit_type "void"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 287106
	comment "! Opens ZIP file.
!
! Argument \\a mode specifies open mode of the ZIP archive. See Mode
! for details. Note that there is zipOpen2() function in the
! ZIP/UNZIP API which accepts \\a globalcomment argument, but it
! does not use it anywhere, so this open() function does not have this
! argument. See setComment() if you need to set global comment.
!
! If the ZIP file is accessed via explicitly set QIODevice, then
! this device is opened in the necessary mode. If the device was
! already opened by some other means, then the behaviour is defined by
! the device implementation, but generally it is not a very good
! idea. For example, QFile will at least issue a warning.
!
! \\return \\c true if successful, \\c false otherwise.
!
! \\note ZIP/UNZIP API open calls do not return error code - they
! just return \\c NULL indicating an error. But to make things
! easier, CrZip.h header defines additional error code \\c
! UNZ_ERROROPEN and getZipError() will return it if the open call
! of the ZIP/UNZIP API returns \\c NULL.
!
! Argument \\a ioApi specifies IO function set for ZIP/UNZIP
! package to use. See unzip.h, zip.h and ioapi.h for details. Note
! that IO API for CrZip is different from the original package.
! The file path argument was changed to be of type \\c voidpf, and
! CrZip passes a QIODevice pointer there. This QIODevice is either
! set explicitly via setIoDevice() or the CrZip(QIODevice*)
! constructor, or it is created internally when opening the archive
! by its file name. The default API (qioapi.cpp) just delegates
! everything to the QIODevice API. Not only this allows to use a
! QIODevice instead of file name, but also has a nice side effect
! of raising the file size limit from 2G to 4G.
!
! In short: just forget about the \\a ioApi argument and you'll be
! fine."
      end

      operation 287234 "close"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 287234
	comment "! Closes ZIP file.
! Call getZipError() to determine if the close was successful. The
! underlying QIODevice is also closed, regardless of whether it was
! set explicitly or not. "
      end

      operation 287362 "setFileNameCodec"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "fileNameCodec" explicit_type "QTextCodec"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 287362
	comment "! Sets the codec used to encode/decode file names inside archive.
! This is necessary to access files in the ZIP archive created
! under Windows with non-latin characters in file names. For
! example, file names with cyrillic letters will be in \\c IBM866
! encoding."
      end

      operation 287490 "setFileNameCodec"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "fileNameCodecName" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 287490
	comment "! Sets the codec used to encode/decode file names inside archive.
!
! \\overload
! Equivalent to calling setFileNameCodec(QTextCodec::codecForName(codecName));"
      end

      operation 287618 "getFileNameCodec"
	preserve_cpp_body_indent const public explicit_return_type "QTextCodec"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} * ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 287618
	comment "! Returns the codec used to encode/decode comments inside archive."
      end

      operation 287746 "setCommentCodec"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "commentCodec" explicit_type "QTextCodec"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 287746
	comment "! Sets the codec used to encode/decode comments inside archive.
! This codec defaults to locale codec, which is probably ok."
      end

      operation 287874 "setCommentCodec"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "commentCodecName" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 287874
	comment "! Sets the codec used to encode/decode comments inside archive.
! \\overload
! Equivalent to calling setCommentCodec(QTextCodec::codecForName(codecName));"
      end

      operation 288002 "getCommentCodec"
	preserve_cpp_body_indent const public explicit_return_type "QTextCodec"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} * ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 288002
	comment "! Returns the codec used to encode/decode comments inside archive."
      end

      operation 288130 "getZipName"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 288130
	comment "! Returns the name of the ZIP file.
! Returns null string if no ZIP file name has been set, for
! example when the CrZip instance is set up to use a QIODevice
! instead.
! \\sa setZipName(), setIoDevice(), getIoDevice()"
      end

      operation 288258 "setZipName"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "zipName" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 288258
	comment "! Sets the name of the ZIP file.
! Does nothing if the ZIP file is open.
!
! Does not reset error code returned by getZipError().
! \\sa setIoDevice(), getIoDevice(), getZipName()"
      end

      operation 288386 "getIoDevice"
	preserve_cpp_body_indent const public return_type class_ref 278274 // CrIODevice
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} * ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 288386
	comment "! Returns the device representing this ZIP file.
! Returns null string if no device has been set explicitly, for
! example when opening a ZIP file by name.
! \\sa setIoDevice(), getZipName(), setZipName()"
      end

      operation 288514 "setIoDevice"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "ioDevice" type class_ref 278274 // CrIODevice
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 288514
	comment "! Sets the device representing the ZIP file.
! Does nothing if the ZIP file is open.
!
! Does not reset error code returned by getZipError().
! \\sa getIoDevice(), getZipName(), setZipName()"
      end

      operation 288642 "getMode"
	preserve_cpp_body_indent const public return_type class_ref 236930 // Mode
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 288642
	comment "! Returns the mode in which ZIP file was opened."
      end

      operation 288770 "isOpen"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 288770
	comment "! Returns \\c true if ZIP file is open, \\c false otherwise."
      end

      operation 288898 "getZipError"
	preserve_cpp_body_indent const public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 288898
	comment "! Returns the error code of the last operation.
! Returns \\c UNZ_OK if the last operation was successful.
!
! Error code resets to \\c UNZ_OK every time you call any function
! that accesses something inside ZIP archive, even if it is \\c
! const (like getEntriesCount()). open() and close() calls reset
! error code too. See documentation for the specific functions for
! details on error detection."
      end

      operation 289026 "getEntriesCount"
	abstract preserve_cpp_body_indent const cpp_virtual public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 289026
	comment "! Returns number of the entries in the ZIP central directory.
! Returns negative error code in the case of error. The same error
! code will be returned by subsequent getZipError() call."
      end

      operation 289154 "getComment"
	abstract preserve_cpp_body_indent const cpp_virtual public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 289154
	comment "! Returns global comment in the ZIP file."
      end

      operation 289282 "setComment"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "comment" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 289282
	comment "! Sets global comment in the ZIP file.
! Comment will be written to the archive on close operation.
!
! \\sa open()"
      end

      operation 289410 "goToFirstFile"
	abstract preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 289410
	comment "! Sets the current file to the first file in the archive.
! Returns \\c true on success, \\c false otherwise. Call
!   getZipError() to get the error code."
      end

      operation 289538 "goToNextFile"
	abstract preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 289538
	comment "! Sets the current file to the next file in the archive.
! Returns \\c true on success, \\c false otherwise. Call
!  getZipError() to determine if there was an error.
!
!  Should be used only in CrZip::mdUnzip mode.

  \\note If the end of file was reached, getZipError() will return
  \\c UNZ_OK instead of \\c UNZ_END_OF_LIST_OF_FILE. This is to make
  things like this easier:
  \\code
  for(bool more=zip.goToFirstFile(); more; more=zip.goToNextFile()) {
    // do something
  }
  if(zip.getZipError()==UNZ_OK) {
    // ok, there was no error
  }
  \\endcode"
      end

      operation 289666 "setCurrentFile"
	abstract preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 2
	  param in name "fileName" explicit_type "string"
	  param in name "cs" type class_ref 237058 // CaseSensitivity
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 289666
	comment "! Sets current file by its name.
! Returns \\c true if successful, \\c false otherwise. Argument \\a
!  cs specifies case sensitivity of the file name. Call
!  getZipError() in the case of a failure to get error code.
!
!  This is not a wrapper to unzLocateFile() function. That is
!  because I had to implement locale-specific case-insensitive
!  comparison.
!
!  Here are the differences from the original implementation:
!
!  - If the file was not found, error code is \\c UNZ_OK, not \\c
!    UNZ_END_OF_LIST_OF_FILE (see also goToNextFile()).
!  - If this function fails, it unsets the current file rather than
!    resetting it back to what it was before the call.
!
!  If \\a fileName is null string then this function unsets the
!  current file and return \\c true. Note that you should close the
!  file first if it is open! See
!  CrZipFile::CrZipFile(CrZip*,QObject*) for the details.
!
!  Should be used only in CrZip::mdUnzip mode.
!
!  \\sa setFileNameCodec(), CaseSensitivity"
      end

      operation 289794 "hasCurrentFile"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 289794
	comment "! Returns \\c true if the current file has been set."
      end

      operation 289922 "getCurrentFileInfo"
	abstract preserve_cpp_body_indent const cpp_virtual public explicit_return_type "bool"
	nparams 1
	  param inout name "info" type class_ref 243586 // CrZipFileInfo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 289922
	comment "! Retrieves information about the current file.
! Fills the structure pointed by \\a info. Returns \\c true on
!  success, \\c false otherwise. In the latter case structure pointed
!  by \\a info remains untouched. If there was an error,
!  getZipError() returns error code.
!
!  Should be used only in CrZip::mdUnzip mode.
!
!  Does nothing and returns \\c false in any of the following cases.
!  - ZIP is not open;
!  - ZIP does not have current file;
!  - \\a info is \\c NULL;
!
!  In all these cases getZipError() returns \\c UNZ_OK since there
!  is no ZIP/UNZIP API call."
      end

      operation 290050 "getCurrentFileName"
	abstract preserve_cpp_body_indent const cpp_virtual public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 290050
	comment "! Returns the current file name.
! Equivalent to calling getCurrentFileInfo() and then getting \\c
!  name field of the CrZipFileInfo structure, but faster and more
!  convenient.
!
!  Should be used only in CrZip::mdUnzip mode."
      end

      operation 193794 "getZipFile"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 193794
	comment "! Returns \\c zipFile handle.
! You can use this handle to directly call ZIP part of the
!  ZIP/UNZIP package functions (see zip.h). Warnings about the
!  getUnzFile() function also apply to this function."
      end

      operation 193666 "getUnzFile"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 193666
	comment "! Returns \\c unzFile handle.
! You can use this handle to directly call UNZIP part of the
!  ZIP/UNZIP package functions (see unzip.h).
!
!  \\warning When using the handle returned by this function, please
!  keep in mind that CrZip class is unable to detect any changes
!  you make in the ZIP file state (e. g. changing current file, or
!  closing the handle). So please do not do anything with this
!  handle that is possible to do with the functions of this class.
!  Or at least return the handle in the original state before
!  calling some another function of this class (including implicit
!  destructor calls and calls from the CrZipFile objects that refer
!  to this CrZip instance!). So if you have changed the current
!  file in the ZIP archive - then change it back or you may
!  experience some strange behavior or even crashes."
      end

      classrelation 236674 // p (<directional aggregation>)
	relation 236674 o-->
	  oid 236674
	  a role_name "p" protected
	    comment "! Private pimpl pointer."
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 236674 // p (<directional aggregation>)
	  b parent class_ref 236034 // CrZipPrivate
	oid 236674
      end
    end

    class 236674 "CrZip"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 236674
      comment "!ZIP archive.
!\\class CrZip CrZip.h <quazip/quazip.h>
! This class implements basic interface to the ZIP archive. It can be
! used to read table contents of the ZIP archive and retreiving
! information about the files inside it.
!
! You can also use this class to open files inside archive by passing
! pointer to the instance of this class to the constructor of the
! CrZipFile class. But see CrZipFile::CrZipFile(CrZip*, QObject*)
! for the possible pitfalls.
!
! This class is indended to provide interface to the ZIP subpackage of
! the ZIP/UNZIP package as well as to the UNZIP subpackage. But
! currently it supports only UNZIP.
!
! The use of this class is simple - just create instance using
! constructor, then set ZIP archive file name using setFile() function
! (if you did not passed the name to the constructor), then open() and
! then use different functions to work with it! Well, if you are
! paranoid, you may also wish to call close before destructing the
! instance, to check for errors on close.
!
! You may also use getUnzFile() and getZipFile() functions to get the
! ZIP archive handle and use it with ZIP/UNZIP package API directly.
!
! This class supports localized file names inside ZIP archive, but you
! have to set up proper codec with setCodec() function. By default,
! locale codec will be used, which is probably ok for UNIX systems, but
! will almost certainly fail with ZIP archives created in Windows. This
! is because Windows ZIP programs have strange habit of using DOS
! encoding for file names in ZIP archives. For example, ZIP archive
! with cyrillic names created in Windows will have file names in \\c
! IBM866 encoding instead of \\c WINDOWS-1251. I think that calling one
! function is not much trouble, but for true platform independency it
! would be nice to have some mechanism for file name encoding auto
! detection using locale information. Does anyone know a good way to do
! it?"
      classrelation 243458 // <generalisation>
	relation 243458 ---|>
	  oid 243458
	  a public
	    cpp default "${type}"
	    classrelation_ref 243458 // <generalisation>
	  b parent class_ref 298754 // CrZipBase
	oid 243458
      end

      classrelation 169858 // <dependency>
	relation 169858 -_->
	  stereotype "friend"
	  oid 169858
	  a default
	    cpp default "${type}"
	    classrelation_ref 169858 // <dependency>
	  b parent class_ref 236034 // CrZipPrivate
	oid 169858
      end

      operation 189826 "CrZip"
	private explicit_return_type ""
	nparams 1
	  param in name "that" type class_ref 236674 // CrZip
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	
	
	
	
	oid 189826
	comment "! not (and will not be) implemented"
      end

      operation 189954 "operator ="
	private return_type class_ref 236674 // CrZip
	nparams 1
	  param in name "that" type class_ref 236674 // CrZip
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 189954
	comment "! not (and will not be) implemented"
      end

      operation 190082 "CrZip"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "//*
// * / Constructs CrZip object.
// * * Call setName() before opening constructed object.

${inline}${class}::${name}${(}${)}:
  CrZipBase()
${throw}{
  ${body}}
"
	
	
	
	
	oid 190082
	comment "! Constructs CrZip object.
! Call setName() before opening constructed object. "
      end

      operation 190210 "CrZip"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param in name "zipName" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}${)}:
  CrZipBase(${p0})
${throw}{
  ${body}}
"
	
	
	
	
	oid 190210
	comment "! Constructs CrZip object associated with ZIP file \\a zipName."
      end

      operation 190338 "CrZip"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "ioDevice" type class_ref 278274 // CrIODevice
	cpp_decl "    ${comment}${inline}${name}${(}${t0} & ${p0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} & ${p0}${)}:
  CrZipBase(${p0})
${throw}{
  ${body}}
"
	
	
	
	
	oid 190338
	comment "! Constructs CrZip object associated with ZIP file represented by \\a ioDevice.
! The IO device must be seekable, otherwise an error will occur when opening. "
      end

      operation 190466 "~CrZip"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
	oid 190466
	comment "! Destroys CrZip object.
! Calls close() if necessary. "
      end

      operation 190594 "open"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 2
	  param in name "mode" type class_ref 236930 // Mode
	  param inout name "ioApi_" explicit_type "void"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 190594
	comment "! Opens ZIP file.
!
! Argument \\a mode specifies open mode of the ZIP archive. See Mode
! for details. Note that there is zipOpen2() function in the
! ZIP/UNZIP API which accepts \\a globalcomment argument, but it
! does not use it anywhere, so this open() function does not have this
! argument. See setComment() if you need to set global comment.
!
! If the ZIP file is accessed via explicitly set QIODevice, then
! this device is opened in the necessary mode. If the device was
! already opened by some other means, then the behaviour is defined by
! the device implementation, but generally it is not a very good
! idea. For example, QFile will at least issue a warning.
!
! \\return \\c true if successful, \\c false otherwise.
!
! \\note ZIP/UNZIP API open calls do not return error code - they
! just return \\c NULL indicating an error. But to make things
! easier, CrZip.h header defines additional error code \\c
! UNZ_ERROROPEN and getZipError() will return it if the open call
! of the ZIP/UNZIP API returns \\c NULL.
!
! Argument \\a ioApi specifies IO function set for ZIP/UNZIP
! package to use. See unzip.h, zip.h and ioapi.h for details. Note
! that IO API for CrZip is different from the original package.
! The file path argument was changed to be of type \\c voidpf, and
! CrZip passes a QIODevice pointer there. This QIODevice is either
! set explicitly via setIoDevice() or the CrZip(QIODevice*)
! constructor, or it is created internally when opening the archive
! by its file name. The default API (qioapi.cpp) just delegates
! everything to the QIODevice API. Not only this allows to use a
! QIODevice instead of file name, but also has a nice side effect
! of raising the file size limit from 2G to 4G.
!
! In short: just forget about the \\a ioApi argument and you'll be
! fine."
      end

      operation 190722 "close"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 190722
	comment "! Closes ZIP file.
! Call getZipError() to determine if the close was successful. The
! underlying QIODevice is also closed, regardless of whether it was
! set explicitly or not. "
      end

      operation 192514 "getEntriesCount"
	preserve_cpp_body_indent const public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 192514
	comment "! Returns number of the entries in the ZIP central directory.
! Returns negative error code in the case of error. The same error
! code will be returned by subsequent getZipError() call."
      end

      operation 192642 "getComment"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 192642
	comment "! Returns global comment in the ZIP file."
      end

      operation 192898 "goToFirstFile"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 192898
	comment "! Sets the current file to the first file in the archive.
! Returns \\c true on success, \\c false otherwise. Call
!   getZipError() to get the error code."
      end

      operation 193026 "goToNextFile"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 193026
	comment "! Sets the current file to the next file in the archive.
! Returns \\c true on success, \\c false otherwise. Call
!  getZipError() to determine if there was an error.
!
!  Should be used only in CrZip::mdUnzip mode.

  \\note If the end of file was reached, getZipError() will return
  \\c UNZ_OK instead of \\c UNZ_END_OF_LIST_OF_FILE. This is to make
  things like this easier:
  \\code
  for(bool more=zip.goToFirstFile(); more; more=zip.goToNextFile()) {
    // do something
  }
  if(zip.getZipError()==UNZ_OK) {
    // ok, there was no error
  }
  \\endcode"
      end

      operation 193154 "setCurrentFile"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 2
	  param in name "fileName" explicit_type "string"
	  param in name "cs" type class_ref 237058 // CaseSensitivity
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 193154
	comment "! Sets current file by its name.
! Returns \\c true if successful, \\c false otherwise. Argument \\a
!  cs specifies case sensitivity of the file name. Call
!  getZipError() in the case of a failure to get error code.
!
!  This is not a wrapper to unzLocateFile() function. That is
!  because I had to implement locale-specific case-insensitive
!  comparison.
!
!  Here are the differences from the original implementation:
!
!  - If the file was not found, error code is \\c UNZ_OK, not \\c
!    UNZ_END_OF_LIST_OF_FILE (see also goToNextFile()).
!  - If this function fails, it unsets the current file rather than
!    resetting it back to what it was before the call.
!
!  If \\a fileName is null string then this function unsets the
!  current file and return \\c true. Note that you should close the
!  file first if it is open! See
!  CrZipFile::CrZipFile(CrZip*,QObject*) for the details.
!
!  Should be used only in CrZip::mdUnzip mode.
!
!  \\sa setFileNameCodec(), CaseSensitivity"
      end

      operation 193410 "getCurrentFileInfo"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 1
	  param inout name "info" type class_ref 243586 // CrZipFileInfo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 193410
	comment "! Retrieves information about the current file.
! Fills the structure pointed by \\a info. Returns \\c true on
!  success, \\c false otherwise. In the latter case structure pointed
!  by \\a info remains untouched. If there was an error,
!  getZipError() returns error code.
!
!  Should be used only in CrZip::mdUnzip mode.
!
!  Does nothing and returns \\c false in any of the following cases.
!  - ZIP is not open;
!  - ZIP does not have current file;
!  - \\a info is \\c NULL;
!
!  In all these cases getZipError() returns \\c UNZ_OK since there
!  is no ZIP/UNZIP API call."
      end

      operation 193538 "getCurrentFileName"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 193538
	comment "! Returns the current file name.
! Equivalent to calling getCurrentFileInfo() and then getting \\c
!  name field of the CrZipFileInfo structure, but faster and more
!  convenient.
!
!  Should be used only in CrZip::mdUnzip mode."
      end
    end

    classdiagram 173826 "CrZip"
      draw_all_relations yes hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition yes show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      oid 173826
      size A4
    end

    class 250242 "QTextCodec"
      visibility package stereotype "typedef" explicit_base_type "int"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 250242
    end

    classdiagram 180354 "CrZipFile"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      oid 180354
      size A3
    end

    class 292226 "CrZipNewInfo"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct PLATFORM_DECL ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 292226
      comment "/ Information about a file to be created.
! This structure holds information about a file to be created inside
! ZIP archive. At least name should be set to something correct before
! passing this structure to
! CrZipFile::open(OpenMode,const CrZipNewInfo&,int,int,bool).
!"
      extra_member 154370 "QDateTime"
	
	cpp "typedef tm_zip QDateTime;
" ""
	java ""
	php ""
	python ""
	idl ""
	oid 154370
      end

      attribute 223746 "name"
	public explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 223746
	comment "/ File name.
! This field holds file name inside archive, including path relative
! to archive root.
!"
      end

      attribute 223874 "dateTime"
	public explicit_type "QDateTime"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 223874
	comment "/ File timestamp.
! This is the last file modification date and time. Will be stored
! in the archive central directory. It is a good practice to set it
! to the source file timestamp instead of archive creating time. Use
! setFileDateTime() or CrZipNewInfo(const std::string&, const std::string&).
!"
      end

      attribute 224002 "internalAttr"
	public explicit_type "uint16_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 224002
	comment "/ File internal attributes."
      end

      attribute 224130 "externalAttr"
	public explicit_type "uint32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 224130
	comment "/ File external attributes."
      end

      attribute 224258 "comment"
	public explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 224258
	comment "/ File comment.
! Will be encoded using CrZip::getCommentCodec().
!"
      end

      attribute 224386 "extraLocal"
	public explicit_type "char"
	stereotype "std::vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 224386
	comment "/ File local extra field."
      end

      attribute 224514 "extraGlobal"
	public explicit_type "char"
	stereotype "std::vector"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 224514
	comment "/ File global extra field."
      end

      attribute 224642 "uncompressedSize"
	public explicit_type "ulong"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 224642
	comment "/ Uncompressed file size.
! This is only needed if you are using raw file zipping mode, i. e.
! adding precompressed file in the zip archive.
!"
      end

      operation 279810 "CrZipNewInfo"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}:
  internalAttr(0), externalAttr(0)
${throw}{
  ${body}}
"
	
	
	
	
	oid 279810
	comment "/ Constructs CrZipNewInfo instance.
! Initializes name with \\a name, dateTime with current date and
! time. Attributes are initialized with zeros, comment and extra
! field with null values.
!"
      end

      operation 272898 "CrZipNewInfo"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param in name "name" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}const ${t0} & ${p0}${)}:
  name(name), internalAttr(0), externalAttr(0)
${throw}{
  ${body}}
"
	
	
	
	
	oid 272898
	comment "/ Constructs CrZipNewInfo instance.
! Initializes name with \\a name, dateTime with current date and
! time. Attributes are initialized with zeros, comment and extra
! field with null values.
!"
      end

      operation 273026 "CrZipNewInfo"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 2
	  param in name "name" explicit_type "string"
	  param in name "file" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}const ${t0} & ${p0}, const ${t1} & ${p1}${)}:
  name(name), internalAttr(0), externalAttr(0)
${throw}{
  ${body}}
"
	
	
	
	
	oid 273026
	comment "/ Constructs CrZipNewInfo instance.
! Initializes name with \\a name and dateTime with timestamp of the
! file named \\a file. If the \\a file does not exists or its timestamp
! is inaccessible (e. g. you do not have read permission for the
! directory file in), uses current date and time. Attributes are
! initialized with zeros, comment and extra field with null values.
!
! \\sa setFileDateTime()
!"
      end

      operation 273154 "setFileDateTime"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "file" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} & ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 273154
	comment "/ Sets the file timestamp from the existing file.
! Use this function to set the file timestamp from the existing
! file. Use it like this:
! \\code
! CrZipFile zipFile(&zip);
! QFile file(\"file-to-add\");
! file.open(QIODevice::ReadOnly);
! CrZipNewInfo info(\"file-name-in-archive\");
! info.setFileDateTime(\"file-to-add\"); // take the timestamp from file
! zipFile.open(QIODevice::WriteOnly, info);
! \\endcode
!
! This function does not change dateTime if some error occured (e. g.
! file is inaccessible).
!"
      end
    end

    class 256770 "CrZipFile"
      visibility package 
      cpp_decl "${comment}${template}class PLATFORM_DECL ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 256770
      comment "! A file inside ZIP archive.
! \\class CrZipFile Crzipfile.h <Crzip/Crzipfile.h>
! This is the most interesting class. Not only it provides C++
! interface to the ZIP/UNZIP package, but also integrates it with Qt by
! subclassing QIODevice. This makes possible to access files inside ZIP
! archive using QTextStream or QDataStream, for example. Actually, this
! is the main purpose of the whole CrZIP library.
!
! You can either use existing CrZip instance to create instance of
! this class or pass ZIP archive file name to this class, in which case
! it will create internal CrZip object. See constructors' descriptions
! for details. Writing is only possible with the existing instance.
!
! \\section quazipfile-sequential Sequential or random-access?
!
! At the first thought, CrZipFile has fixed size, the start and the
! end and should be therefore considered random-access device. But
! there is one major obstacle to making it random-access: ZIP/UNZIP API
! does not support seek() operation and the only way to implement it is
! through reopening the file and re-reading to the required position,
! but this is prohibitely slow.
!
! Therefore, CrZipFile is considered to be a sequential device. This
! has advantage of availability of the ungetChar() operation (QIODevice
! does not implement it properly for non-sequential devices unless they
! support seek()). Disadvantage is a somewhat strange behaviour of the
! size() and pos() functions. This should be kept in mind while using
! this class.
/
/ \\note This class has function names in lowercase for compatibility
/ with QT4."
      classrelation 189826 // <dependency>
	relation 189826 -_->
	  stereotype "friend"
	  oid 189826
	  a default
	    cpp default "${type}"
	    classrelation_ref 189826 // <dependency>
	  b parent class_ref 257026 // CrZipFilePrivate
	oid 189826
      end

      classrelation 189954 // p (<unidirectional association>)
	relation 189954 --->
	  oid 189954
	  a role_name "p" private
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 189954 // p (<unidirectional association>)
	  b parent class_ref 257026 // CrZipFilePrivate
	oid 189954
      end

      operation 207234 "CrZipFile"
	private explicit_return_type ""
	nparams 1
	  param in name "that" type class_ref 256770 // CrZipFile
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	
	
	
	
	oid 207234
	comment "! these are not supported nor implemented"
      end

      operation 207362 "operator ="
	private return_type class_ref 256770 // CrZipFile
	nparams 1
	  param in name "that" type class_ref 256770 // CrZipFile
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 207362
	comment "! these are not supported nor implemented"
      end

      operation 207490 "readData"
	preserve_cpp_body_indent protected explicit_return_type "int64_t"
	nparams 2
	  param inout name "data" explicit_type "char"
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 207490
	comment "/ Implementation of the QIODevice::readData()."
      end

      operation 207618 "writeData"
	preserve_cpp_body_indent protected explicit_return_type "int64_t"
	nparams 2
	  param in name "data" explicit_type "char"
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 207618
	comment "/ Implementation of the QIODevice::writeData()."
      end

      operation 207746 "CrZipFile"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}:
  p(new CrZipFilePrivate(this))
${throw}{
  ${body}}
"
	
	
	
	
	oid 207746
	comment "/ Constructs a CrZipFile instance.
! You should use setZipName() and setFileName() or setZip() before
! trying to call open() on the constructed object.
"
      end

      operation 208002 "CrZipFile"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param in name "zipName" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}${)}:
  CrIODevice(),
  p(new CrZipFilePrivate(this, zipName))
${throw}{
  ${body}}
"
	
	
	
	
	oid 208002
	comment "! Constructs a CrZipFile instance.
! \\a parent argument specifies this object's parent object and \\a
! zipName specifies ZIP archive file name.
!
! You should use setFileName() before trying to call open() on the
! constructed object.
!
! CrZipFile constructed by this constructor can be used for read
! only access. Use CrZipFile(CrZip*,QObject*) for writing."
      end

      operation 208130 "CrZipFile"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 3
	  param in name "zipName" explicit_type "string"
	  param in name "fileName" explicit_type "string"
	  param in name "cs" type class_ref 237058 // CaseSensitivity
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}:
  CrIODevice(),
  p(new CrZipFilePrivate(this, zipName, fileName, cs))
${throw}{
  ${body}}
"
	
	
	
	
	oid 208130
	comment "! Constructs a CrZipFile instance.
! \\a parent argument specifies this object's parent object, \\a
! zipName specifies ZIP archive file name and \\a fileName and \\a cs
! specify a name of the file to open inside archive.
!
! CrZipFile constructed by this constructor can be used for read
! only access. Use CrZipFile(CrZip*,QObject*) for writing.
!
! \\sa CrZip::setCurrentFile()"
      end

      operation 208258 "CrZipFile"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "zip" type class_ref 236674 // CrZip
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} * ${p0}${)}${throw} :
  CrIODevice(),
  p(new CrZipFilePrivate(this, zip)) {
  ${body}}
"
	
	
	
	
	oid 208258
	comment "/ Constructs a CrZipFile instance.
! \\a parent argument specifies this object's parent object.
!
! \\a zip is the pointer to the existing CrZip object. This
! CrZipFile object then can be used to read current file in the
! \\a zip or to write to the file inside it.
!
! \\warning Using this constructor for reading current file can be
! tricky. Let's take the following example:
! \\code
! CrZip zip(\"archive.zip\");
! zip.open(CrZip::mdUnzip);
! zip.setCurrentFile(\"file-in-archive\");
! CrZipFile file(&zip);
! file.open(QIODevice::ReadOnly);
! // ok, now we can read from the file
! file.read(somewhere, some);
! zip.setCurrentFile(\"another-file-in-archive\"); // oops...
! CrZipFile anotherFile(&zip);
! anotherFile.open(QIODevice::ReadOnly);
! anotherFile.read(somewhere, some); // this is still ok...
! file.read(somewhere, some); // and this is NOT
! \\endcode
! So, what exactly happens here? When we change current file in the
! \\c zip archive, \\c file that references it becomes invalid
! (actually, as far as I understand ZIP/UNZIP sources, it becomes
! closed, but CrZipFile has no means to detect it).
!
! Summary: do not close \\c zip object or change its current file as
! long as CrZipFile is open. Even better - use another constructors
! which create internal CrZip instances, one per object, and
! therefore do not cause unnecessary trouble. This constructor may
! be useful, though, if you already have a CrZip instance and do
! not want to access several files at once. Good example:
! \\code
! CrZip zip(\"archive.zip\");
! zip.open(CrZip::mdUnzip);
! // first, we need some information about archive itself
! QByteArray comment=zip.getComment();
! // and now we are going to access files inside it
! CrZipFile file(&zip);
! for(bool more=zip.goToFirstFile(); more; more=zip.goToNextFile()) {
!   file.open(QIODevice::ReadOnly);
!   // do something cool with file here
!   file.close(); // do not forget to close!
! }
! zip.close();
! \\endcode
!"
      end

      operation 208386 "~CrZipFile"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
	oid 208386
	comment "/ Destroys a CrZipFile instance.
! Closes file if open, destructs internal CrZip object (if it
! exists and \\em is internal, of course).
!"
      end

      operation 208514 "getZipName"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 208514
	comment "/ Returns the ZIP archive file name.
! If this object was created by passing CrZip pointer to the
! constructor, this function will return that CrZip's file name
! (or null string if that object does not have file name yet).
!
! Otherwise, returns associated ZIP archive file name or null
! string if there are no name set yet.
!
! \\sa setZipName() getFileName()
!"
      end

      operation 208642 "getZip"
	const public return_type class_ref 236674 // CrZip
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} * ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 208642
	comment "/ Returns a pointer to the associated CrZip object.
! Returns \\c NULL if there is no associated CrZip or it is
! internal (so you will not mess with it)."
      end

      operation 208770 "getFileName"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 208770
	comment "/ Returns file name.
! This function returns file name you passed to this object either
! by using
! CrZipFile(const QString&,const QString&,CrZip::CaseSensitivity,QObject*)
! or by calling setFileName(). Real name of the file may differ in
! case if you used case-insensitivity.
!
! Returns null string if there is no file name set yet. This is the
! case when this CrZipFile operates on the existing CrZip object
! (constructor CrZipFile(CrZip*,QObject*) or setZip() was used).
!
! \\sa getActualFileName
!"
      end

      operation 208898 "getCaseSensitivity"
	preserve_cpp_body_indent const public return_type class_ref 237058 // CaseSensitivity
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 208898
	comment "/ Returns case sensitivity of the file name.
! This function returns case sensitivity argument you passed to
! this object either by using
! CrZipFile(const QString&,const QString&,CrZip::CaseSensitivity,QObject*)
! or by calling setFileName().
!
! Returns unpredictable value if getFileName() returns null string
! (this is the case when you did not used setFileName() or
! constructor above).
!
! \\sa getFileName
!"
      end

      operation 209026 "getActualFileName"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 209026
	comment "/ Returns the actual file name in the archive.
! This is \\em not a ZIP archive file name, but a name of file inside
! archive. It is not necessary the same name that you have passed
! to the
! CrZipFile(const QString&,const QString&,CrZip::CaseSensitivity,QObject*),
! setFileName() or CrZip::setCurrentFile() - this is the real file
! name inside archive, so it may differ in case if the file name
! search was case-insensitive.
!
! Equivalent to calling getCurrentFileName() on the associated
! CrZip object. Returns null string if there is no associated
! CrZip object or if it does not have a current file yet. And this
! is the case if you called setFileName() but did not open the
! file yet. So this is perfectly fine:
! \\code
! CrZipFile file(\"somezip.zip\");
! file.setFileName(\"somefile\");
! QString name=file.getName(); // name==\"somefile\"
! QString actual=file.getActualFileName(); // actual is null string
! file.open(QIODevice::ReadOnly);
! QString actual=file.getActualFileName(); // actual can be \"SoMeFiLe\" on Windows
! \\endcode
!
! \\sa getZipName(), getFileName(), CrZip::CaseSensitivity
!"
      end

      operation 209154 "setZipName"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "zipName" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 209154
	comment "/ Sets the ZIP archive file name.
! Automatically creates internal CrZip object and destroys
! previously created internal CrZip object, if any.
!
! Will do nothing if this file is already open. You must close() it
! first.
!"
      end

      operation 209282 "isRaw"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 209282
	comment "/ Returns \\c true if the file was opened in raw mode.
! If the file is not open, the returned value is undefined.
!
! \\sa open(OpenMode,int*,int*,bool,const char*)
!"
      end

      operation 209410 "setZip"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param inout name "zip" type class_ref 236674 // CrZip
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 209410
	comment "/ Binds to the existing CrZip instance.
! This function destroys internal CrZip object, if any, and makes
! this CrZipFile to use current file in the \\a zip object for any
! further operations. See CrZipFile(CrZip*,QObject*) for the
! possible pitfalls.
!
! Will do nothing if the file is currently open. You must close()
! it first.
!"
      end

      operation 209538 "setFileName"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 2
	  param in name "fileName" explicit_type "string"
	  param in name "cs" type class_ref 237058 // CaseSensitivity
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 209538
	comment "/ Sets the file name.
! Will do nothing if at least one of the following conditions is
! met:
! - ZIP name has not been set yet (getZipName() returns null
!   string).
! - This CrZipFile is associated with external CrZip. In this
!   case you should call that CrZip's setCurrentFile() function
!   instead!
! - File is already open so setting the name is meaningless.
!
! \\sa CrZip::setCurrentFile
!"
      end

      operation 209666 "open"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 1
	  param in name "mode" explicit_type "OpenMode"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 209666
	comment "/ Opens a file for reading.
! Returns \\c true on success, \\c false otherwise.
! Call getZipError() to get error code.
!
! \\note Since ZIP/UNZIP API provides buffered reading only,
! CrZipFile does not support unbuffered reading. So do not pass
! QIODevice::Unbuffered flag in \\a mode, or open will fail.
!"
      end

      operation 209794 "open"
	cpp_inline public explicit_return_type "bool"
	nparams 2
	  param in name "mode" explicit_type "OpenMode"
	  param in name "password" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {return open(mode, NULL, NULL, false, password);};
"
	
	
	
	
	oid 209794
	comment "/ Opens a file for reading.
! \\overload
! Argument \\a password specifies a password to decrypt the file. If
! it is NULL then this function behaves just like open(OpenMode).
!"
      end

      operation 209922 "open"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 5
	  param in name "mode" explicit_type "OpenMode"
	  param inout name "method" explicit_type "int"
	  param inout name "level" explicit_type "int"
	  param in name "raw" explicit_type "bool"
	  param in name "password" explicit_type "char"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} * ${p2}${v2}, ${t3} ${p3}${v3}, const ${t4} * ${p4}${v4}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} * ${p1}, ${t2} * ${p2}, ${t3} ${p3}, const ${t4} * ${p4}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 209922
	comment "/ Opens a file for reading.
! \\overload
! Argument \\a password specifies a password to decrypt the file.
!
! An integers pointed by \\a method and \\a level will receive codes
! of the compression method and level used. See unzip.h.
!
! If raw is \\c true then no decompression is performed.
!
! \\a method should not be \\c NULL. \\a level can be \\c NULL if you
! don't want to know the compression level.
!"
      end

      operation 210050 "open"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 10
	  param in name "mode" explicit_type "OpenMode"
	  param in name "info" type class_ref 292226 // CrZipNewInfo
	  param in name "password" explicit_type "char"
	    defaultvalue "NULL"
	  param in name "crc" explicit_type "uint32_t"
	    defaultvalue "0"
	  param in name "method" explicit_type "int"
	    defaultvalue "Z_DEFLATED"
	  param in name "level" explicit_type "int"
	    defaultvalue "Z_DEFAULT_COMPRESSION"
	  param in name "raw" explicit_type "bool"
	    defaultvalue "false"
	  param in name "windowBits" explicit_type "int"
	    defaultvalue "-MAX_WBITS"
	  param in name "memLevel" explicit_type "int"
	    defaultvalue "DEF_MEM_LEVEL"
	  param in name "strategy" explicit_type "int"
	    defaultvalue "Z_DEFAULT_STRATEGY"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, const ${t1} & ${p1}, const ${t2} * ${p2}${v2}, const ${t3} ${p3}${v3}, ${t4} ${p4}${v4}, ${t5} ${p5}${v5}, ${t6} ${p6}${v6}, ${t7} ${p7}${v7}, ${t8} ${p8}${v8}, ${t9} ${p9}${v9}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, const ${t1} & ${p1}, const ${t2} * ${p2}, const ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6} ${p6}, ${t7} ${p7}, ${t8} ${p8}, ${t9} ${p9}${)}${const}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 210050
	comment "/ Opens a file for writing.
! \\a info argument specifies information about file. It should at
! least specify a correct file name. Also, it is a good idea to
! specify correct timestamp (by default, current time will be
! used). See CrZipNewInfo.
!
! Arguments \\a password and \\a crc provide necessary information
! for crypting. Note that you should specify both of them if you
! need crypting. If you do not, pass \\c NULL as password, but you
! still need to specify \\a crc if you are going to use raw mode
! (see below).
!
! Arguments \\a method and \\a level specify compression method and
! level.
!
! If \\a raw is \\c true, no compression is performed. In this case,
! \\a crc and uncompressedSize field of the \\a info are required.
!
! Arguments \\a windowBits, \\a memLevel, \\a strategy provide zlib
! algorithms tuning. See deflateInit2() in zlib.
!"
      end

      operation 210178 "isSequential"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 210178
	comment "/ Returns \\c true, but \\ref quazipfile-sequential \"beware\"!"
      end

      operation 210306 "pos"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "int64_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 210306
	comment "/ Returns current position in the file.
! Implementation of the CrIODevice::pos(). When reading, this
! function is a wrapper to the ZIP/UNZIP unztell(), therefore it is
! unable to keep track of the ungetChar() calls (which is
! non-virtual and therefore is dangerous to reimplement). So if you
! are using ungetChar() feature of the QCrIODevice, this function
! reports incorrect value until you get back characters which you
! ungot.
!
! When writing, pos() returns number of bytes already written
! (uncompressed unless you use raw mode).
!
! \\note Although
! \\ref quazipfile-sequential \"CrZipFile is a sequential device\"
! and therefore pos() should always return zero, it does not,
! because it would be misguiding. Keep this in mind.
!
! This function returns -1 if the file or archive is not open.
!
! Error code returned by getZipError() is not affected by this
! function call.
!"
      end

      operation 210434 "atEnd"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 210434
	comment "/ Returns \\c true if the end of file was reached.
! This function returns \\c false in the case of error. This means
! that you called this function on either not open file, or a file
! in the not open archive or even on a CrZipFile instance that
! does not even have CrZip instance associated. Do not do that
! because there is no means to determine whether \\c false is
! returned because of error or because end of file was reached.
! Well, on the other side you may interpret \\c false return value
! as \"there is no file open to check for end of file and there is
! no end of file therefore\".
!
! When writing, this function always returns \\c true (because you
! are always writing to the end of file).
!
! Error code returned by getZipError() is not affected by this
! function call.
!"
      end

      operation 210562 "size"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "int64_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 210562
	comment "/ Returns file size.
! This function returns csize() if the file is open for reading in
! raw mode, usize() if it is open for reading in normal mode and
! pos() if it is open for writing.
!
! Returns -1 on error, call getZipError() to get error code.
!
! \\note This function returns file size despite that
! \\ref quazipfile-sequential \"CrZipFile is considered to be sequential device\",
! for which size() should return bytesAvailable() instead. But its
! name would be very misguiding otherwise, so just keep in mind
! this inconsistence.
!"
      end

      operation 210690 "csize"
	preserve_cpp_body_indent const public explicit_return_type "int64_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 210690
	comment "/ Returns compressed file size.
! Equivalent to calling getFileInfo() and then getting
! compressedSize field, but more convenient and faster.
!
! File must be open for reading before calling this function.
!
! Returns -1 on error, call getZipError() to get error code.
!"
      end

      operation 210818 "usize"
	preserve_cpp_body_indent const public explicit_return_type "int64_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 210818
	comment "/ Returns uncompressed file size.
! Equivalent to calling getFileInfo() and then getting
! uncompressedSize field, but more convenient and faster. See
! getFileInfo() for a warning.
!
! File must be open for reading before calling this function.
!
! Returns -1 on error, call getZipError() to get error code.
!"
      end

      operation 210946 "getFileInfo"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 1
	  param inout name "info" type class_ref 243586 // CrZipFileInfo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 210946
	comment "/ Gets information about current file.
! This function does the same thing as calling
! CrZip::getCurrentFileInfo() on the associated CrZip object,
! but you can not call getCurrentFileInfo() if the associated
! CrZip is internal (because you do not have access to it), while
! you still can call this function in that case.
!
! File must be open for reading before calling this function.
!
! Returns \\c false in the case of an error.
!"
      end

      operation 211074 "close"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 211074
	comment "/ Closes the file.
! Call getZipError() to determine if the close was successful.
!"
      end

      operation 211202 "getZipError"
	preserve_cpp_body_indent const public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 211202
	comment "/ Returns the error code returned by the last ZIP/UNZIP API call."
      end

      classrelation 230018 // <generalisation>
	relation 230018 ---|>
	  oid 230018
	  a public
	    cpp default "${type}"
	    classrelation_ref 230018 // <generalisation>
	  b parent class_ref 278274 // CrIODevice
	oid 230018
      end
    end

    class 257026 "CrZipFilePrivate"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 257026
      classrelation 190082 // <dependency>
	relation 190082 -_->
	  stereotype "friend"
	  oid 190082
	  a default
	    cpp default "${type}"
	    classrelation_ref 190082 // <dependency>
	  b parent class_ref 256770 // CrZipFile
	oid 190082
      end

      class 305666 "ArchiveType"
	visibility package stereotype "enum"
	cpp_decl "${comment}enum ${name} {
${items}
};
"
	java_decl "${comment}${@}${visibility}${final}${abstract}enum ${name}${implements} {
${items};
${members}}
"
	php_decl "${comment}${visibility}final class ${name} {
${items}}
"
	python_2_2 python_decl "class ${name}:
${docstring}${members}
"
	idl_decl "${comment}enum ${name} {
${items}};
"
	explicit_switch_type ""
	
	oid 305666
	attribute 231554 "undefined"
	  public type class_ref 305666 // ArchiveType
	  init_value "0"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 231554
	end

	attribute 231170 "zipfile"
	  public type class_ref 305666 // ArchiveType
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 231170
	end

	attribute 231682 "rarfile"
	  public type class_ref 305666 // ArchiveType
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 231682
	end
      end

      classrelation 190210 // q (<unidirectional association>)
	relation 190210 --->
	  oid 190210
	  a role_name "q" private
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 190210 // q (<unidirectional association>)
	  b parent class_ref 256770 // CrZipFile
	oid 190210
      end

      attribute 231810 "type"
	private type class_ref 305666 // ArchiveType
	init_value "undefined"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 231810
      end

      attribute 186754 "zip"
	private type class_ref 298754 // CrZipBase
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 186754
      end

      attribute 186882 "fileName"
	private explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 186882
      end

      attribute 187010 "caseSensitivity"
	private type class_ref 237058 // CaseSensitivity
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 187010
      end

      attribute 187138 "raw"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 187138
      end

      attribute 187266 "writePos"
	private explicit_type "int64_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 187266
      end

      attribute 187394 "uncompressedSize"
	private explicit_type "ulong"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 187394
	comment " these two are for writing raw files"
      end

      attribute 187522 "crc"
	private explicit_type "uint32_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 187522
      end

      attribute 187650 "internal"
	private explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 187650
      end

      attribute 187778 "zipError"
	private explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 187778
      end

      operation 211330 "resetZipError"
	const cpp_inline private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {setZipError(UNZ_OK);};
"
	
	
	
	
	oid 211330
      end

      operation 211458 "setZipError"
	preserve_cpp_body_indent const private explicit_return_type "void"
	nparams 1
	  param in name "zipError" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 211458
	comment " const, but sets zipError!"
      end

      operation 211586 "CrZipFilePrivate"
	cpp_inline private explicit_return_type ""
	nparams 1
	  param inout name "q" type class_ref 256770 // CrZipFile
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}${)}${volatile}${throw} :
      q(q), zip(NULL), internal(true), zipError(UNZ_OK) {};
"
	
	
	
	
	oid 211586
      end

      operation 211714 "CrZipFilePrivate"
	cpp_inline private explicit_return_type ""
	nparams 2
	  param inout name "q" type class_ref 256770 // CrZipFile
	  param in name "zipName" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${)}${volatile}${throw} :
      q(q), internal(true), zipError(UNZ_OK)
      {
        zip=new CrZip(zipName);
      };
"
	
	
	
	
	oid 211714
      end

      operation 211842 "CrZipFilePrivate"
	cpp_inline private explicit_return_type ""
	nparams 4
	  param inout name "q" type class_ref 256770 // CrZipFile
	  param in name "zipName" explicit_type "string"
	  param in name "fileName" explicit_type "string"
	  param in name "cs" type class_ref 237058 // CaseSensitivity
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${volatile}${throw} :
      q(q), internal(true), zipError(UNZ_OK)
      {
        zip=new CrZip(zipName);
        this->fileName=fileName;
        this->caseSensitivity=cs;
      };
"
	
	
	
	
	oid 211842
      end

      operation 211970 "CrZipFilePrivate"
	cpp_inline private explicit_return_type ""
	nparams 2
	  param inout name "q" type class_ref 256770 // CrZipFile
	  param inout name "zip" type class_ref 236674 // CrZip
	cpp_decl "    ${comment}${inline}${name}${(}${t0} * ${p0}${v0}, ${t1} * ${p1}${)}${volatile}${throw} :
      q(q), zip(zip), internal(false), zipError(UNZ_OK) {};
"
	
	
	
	
	oid 211970
      end

      operation 212098 "~CrZipFilePrivate"
	cpp_inline private explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
      if (internal)
        delete zip;
    };
"
	
	
	
	
	oid 212098
      end
    end

    classdiagram 186882 "CrIODevice"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      oid 186882
      size A3
    end

    class 263682 "CrIODevicePrivateLinearBuffer"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 263682
      comment " This is CrIODevice's read buffer, optimized for read(), isEmpty() and getChar()"
      class 263810 "FreeSpacePos"
	visibility package stereotype "enum"
	cpp_decl "${comment}enum ${name} {
${items}
};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	oid 263810
	attribute 194306 "freeSpaceAtStart"
	  public type class_ref 263810 // FreeSpacePos
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 194306
	end

	attribute 194434 "freeSpaceAtEnd"
	  public type class_ref 263810 // FreeSpacePos
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 194434
	end
      end

      operation 218626 "CrIODevicePrivateLinearBuffer"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param in name "" explicit_type "int"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw} : len(0), first(0), buf(0), capacity(0) {
    };
"
	
	
	
	
	oid 218626
      end

      operation 218754 "~CrIODevicePrivateLinearBuffer"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw} {
        delete [] buf;
    };
"
	
	
	
	
	oid 218754
      end

      operation 218882 "clear"
	cpp_inline public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        first = buf;
        len = 0;
    };
"
	
	
	
	
	oid 218882
      end

      operation 219010 "size"
	const cpp_inline public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return len;
    };
"
	
	
	
	
	oid 219010
      end

      operation 219138 "isEmpty"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return len == 0;
    };
"
	
	
	
	
	oid 219138
      end

      operation 219266 "skip"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "n" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        if (n >= len) {
            clear();
        }
        else {
            len -= n;
            first += n;
        }
    };
"
	
	
	
	
	oid 219266
      end

      operation 219394 "getChar"
	cpp_inline public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        if (len == 0)
            return -1;

        int ch = unsigned char(*first);

        len--;

        first++;

        return ch;
    };
"
	
	
	
	
	oid 219394
      end

      operation 219522 "read"
	cpp_inline public explicit_return_type "int"
	nparams 2
	  param inout name "target" explicit_type "char"
	  param in name "size" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        int r = qMin(size, len);
        memcpy(target, first, r);
        len -= r;
        first += r;
        return r;
    };
"
	
	
	
	
	oid 219522
      end

      operation 219650 "reserve"
	cpp_inline public explicit_return_type "char"
	nparams 1
	  param in name "size" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        makeSpace(size + len, freeSpaceAtEnd);
        char* writePtr = first + len;
        len += size;
        return writePtr;
    };
"
	
	
	
	
	oid 219650
      end

      operation 219778 "chop"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "size" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        if (size >= len) {
            clear();
        }
        else {
            len -= size;
        }
    };
"
	
	
	
	
	oid 219778
      end

      operation 219906 "readAll"
	cpp_inline public explicit_return_type "std::vector<char>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        char* f = first;
        int l = len;
        clear();
        std::vector<char> bytes(*f,l);
        return bytes;
        //return QByteArray(f, l);
    };
"
	
	
	
	
	oid 219906
      end

      operation 220034 "readLine"
	cpp_inline public explicit_return_type "int"
	nparams 2
	  param inout name "target" explicit_type "char"
	  param in name "size" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        int r = qMin(size, len);
        char* eol = static_cast<char*>(memchr(first, '\\n', r));

        if (eol)
            r = 1 + (eol - first);

        memcpy(target, first, r);

        len -= r;

        first += r;

        return int(r);
    };
"
	
	
	
	
	oid 220034
      end

      operation 220162 "canReadLine"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        return memchr(first, '\\n', len);
    };
"
	
	
	
	
	oid 220162
      end

      operation 220290 "ungetChar"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "c" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        if (first == buf) {
            // underflow, the existing valid data needs to move to the end of the (potentially bigger) buffer
            makeSpace(len + 1, freeSpaceAtStart);
        }

        first--;

        len++;
        *first = c;
    };
"
	
	
	
	
	oid 220290
      end

      operation 220418 "ungetBlock"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param in name "block" explicit_type "char"
	  param in name "size" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        if ((first - buf) < size) {
            // underflow, the existing valid data needs to move to the end of the (potentially bigger) buffer
            makeSpace(len + size, freeSpaceAtStart);
        }

        first -= size;

        len += size;
        memcpy(first, block, size);
    };
"
	
	
	
	
	oid 220418
      end

      operation 220546 "makeSpace"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param in name "required" explicit_type "size_t"
	  param in name "where" type class_ref 263810 // FreeSpacePos
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        size_t newCapacity = qMax(capacity, size_t(CRIODEVICE_BUFFERSIZE));

        while (newCapacity < required)
            newCapacity *= 2;

        int moveOffset = (where == freeSpaceAtEnd) ? 0 : newCapacity - len;

        if (newCapacity > capacity) {
            // allocate more space
            char* newBuf = new char[newCapacity];
            memmove(newBuf + moveOffset, first, len);
            delete [] buf;
            buf = newBuf;
            capacity = newCapacity;
        }
        else {
            // shift any existing data to make space
            memmove(buf + moveOffset, first, len);
        }

        first = buf + moveOffset;
    };
"
	
	
	
	
	oid 220546
      end

      attribute 194562 "len"
	private explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 194562
	comment " length of the unread data"
      end

      attribute 194690 "first"
	private explicit_type "char"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 194690
	comment " start of the unread data"
      end

      attribute 194818 "buf"
	private explicit_type "char"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 194818
	comment " the allocated buffer"
      end

      attribute 194946 "capacity"
	private explicit_type "size_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 194946
	comment " allocated buffer size"
      end
    end

    class 263938 "CrIODevicePrivate"
      visibility package 
      cpp_decl "${comment}${template}class PLATFORM_DECL ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 263938
      class 264066 "AccessMode"
	visibility package stereotype "enum"
	cpp_decl "${comment}enum ${name} {
${items}
};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	oid 264066
	attribute 196226 "Unset"
	  public type class_ref 264066 // AccessMode
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 196226
	end

	attribute 196354 "Sequential"
	  public type class_ref 264066 // AccessMode
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 196354
	end

	attribute 196482 "RandomAccess"
	  public type class_ref 264066 // AccessMode
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 196482
	end
      end

      classrelation 223106 // <dependency>
	relation 223106 -_->
	  stereotype "friend"
	  oid 223106
	  a package
	    cpp default "${type}"
	    classrelation_ref 223106 // <dependency>
	  b parent class_ref 278274 // CrIODevice
	oid 223106
      end

      operation 221314 "q_func"
	cpp_inline private explicit_return_type "CrIODevice"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return static_cast<CrIODevice *>(q_ptr); };
"
	
	
	
	
	oid 221314
      end

      operation 221442 "q_func"
	const cpp_inline private explicit_return_type "CrIODevice"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} { return static_cast<const CrIODevice *>(q_ptr); };
"
	
	
	
	
	oid 221442
      end

      operation 221570 "CrIODevicePrivate"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} 
    : openMode(CrIODevice::NotOpen), buffer(CRIODEVICE_BUFFERSIZE), 
      pos(0), devicePos(0) 
       , pPos(&pos), pDevicePos(&devicePos) 
       , baseReadLineDataCalled(false) 
       , firstRead(true) 
       , accessMode(Unset) 
       , q_ptr(0) {
  ${body}}
"
	
	
	
	
	oid 221570
	comment "! \\internal "
      end

      operation 220674 "~CrIODevicePrivate"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw} {
  ${body}}
"
	
	
	
	
	oid 220674
	comment "! \\internal"
      end

      attribute 195074 "openMode"
	public explicit_type "CrIODevice::OpenMode"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 195074
      end

      attribute 195202 "errorString"
	public explicit_type "string"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 195202
      end

      classrelation 196866 // buffer (<directional composition>)
	relation 196866 *-->
	  oid 196866
	  a role_name "buffer" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 196866 // buffer (<directional composition>)
	  b parent class_ref 263682 // CrIODevicePrivateLinearBuffer
	oid 196866
      end

      attribute 195330 "pos"
	public explicit_type "int64_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 195330
      end

      attribute 195458 "devicePos"
	public explicit_type "int64_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 195458
      end

      attribute 195586 "seqDumpPos"
	public explicit_type "int64_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 195586
	comment " these three are for fast position updates during read, avoiding isSequential test"
      end

      attribute 195714 "pPos"
	public explicit_type "int64_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 195714
      end

      attribute 195842 "pDevicePos"
	public explicit_type "int64_t"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 195842
      end

      attribute 195970 "baseReadLineDataCalled"
	public explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 195970
      end

      attribute 196098 "firstRead"
	public explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 196098
      end

      operation 220802 "putCharHelper"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 1
	  param in name "c" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 220802
	comment "!  \\internal 
"
      end

      classrelation 196994 // accessMode (<directional composition>)
	relation 196994 *-->
	  oid 196994
	  a role_name "accessMode" public
	    cpp mutable default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 196994 // accessMode (<directional composition>)
	  b parent class_ref 264066 // AccessMode
	oid 196994
      end

      operation 220930 "isSequential"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
        if (accessMode == Unset)
            accessMode = q_func()->isSequential() ? Sequential : RandomAccess;

        return accessMode == Sequential;
    };
"
	
	
	
	
	oid 220930
      end

      operation 221058 "peek"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "int64_t"
	nparams 2
	  param inout name "data" explicit_type "char"
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 221058
	comment "! \\internal "
      end

      operation 266370 "peek"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "std::vector<char>"
	nparams 1
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 266370
	comment "! \\internal "
      end

      classrelation 223234 // q_ptr (<directional aggregation>)
	relation 223234 o-->
	  oid 223234
	  a role_name "q_ptr" private
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 223234 // q_ptr (<directional aggregation>)
	  b parent class_ref 278274 // CrIODevice
	oid 223234
      end
    end

    class 278146 "Status"
      visibility package stereotype "typedef" explicit_base_type "int"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 278146
    end

    class 278274 "CrIODevice"
      abstract visibility package 
      cpp_decl "${comment}${template}class PLATFORM_DECL ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 278274
      comment "/
/ \\class CrIODevice
/ \\reentrant
/
/ \\brief The CrIODevice class is the base interface class of all I/O
/ devices in Qt.
/
/ \\ingroup io
/
/ CrIODevice provides both a common implementation and an abstract
/ interface for devices that support reading and writing of blocks
/ of data, such as QFile, QBuffer and QTcpSocket. CrIODevice is
/ abstract and can not be instantiated, but it is common to use the
/ interface it defines to provide device-independent I/O features.
/ For example, Qt's XML classes operate on a CrIODevice pointer,
/ allowing them to be used with various devices (such as files and
/ buffers).
/
/ Before accessing the device, open() must be called to set the
/ correct OpenMode (such as ReadOnly or ReadWrite). You can then
/ write to the device with write() or putChar(), and read by calling
/ either read(), readLine(), or readAll(). Call close() when you are
/ done with the device.
/
/ CrIODevice distinguishes between two types of devices:
/ random-access devices and sequential devices.
/
/ \\list
/ \\o Random-access devices support seeking to arbitrary
/ positions using seek(). The current position in the file is
/ available by calling pos(). QFile and QBuffer are examples of
/ random-access devices.
/
/ \\o Sequential devices don't support seeking to arbitrary
/ positions. The data must be read in one pass. The functions
/ pos() and size() don't work for sequential devices.
/ QTcpSocket and QProcess are examples of sequential devices.
/ \\endlist
/
/ You can use isSequential() to determine the type of device.
/
/ CrIODevice emits readyRead() when new data is available for
/ reading; for example, if new data has arrived on the network or if
/ additional data is appended to a file that you are reading
/ from. You can call bytesAvailable() to determine the number of
/ bytes that are currently available for reading. It's common to use
/ bytesAvailable() together with the readyRead() signal when
/ programming with asynchronous devices such as QTcpSocket, where
/ fragments of data can arrive at arbitrary points in
/ time. CrIODevice emits the bytesWritten() signal every time a
/ payload of data has been written to the device. Use bytesToWrite()
/ to determine the current amount of data waiting to be written.
/
/ Certain subclasses of CrIODevice, such as QTcpSocket and QProcess,
/ are asynchronous. This means that I/O functions such as write()
/ or read() always return immediately, while communication with the
/ device itself may happen when control goes back to the event loop.
/ CrIODevice provides functions that allow you to force these
/ operations to be performed immediately, while blocking the
/ calling thread and without entering the event loop. This allows
/ CrIODevice subclasses to be used without an event loop, or in
/ a separate thread:
/
/ \\list
/ \\o waitForReadyRead() - This function suspends operation in the
/ calling thread until new data is available for reading.
/
/ \\o waitForBytesWritten() - This function suspends operation in the
/ calling thread until one payload of data has been written to the
/ device.
/
/ \\o waitFor....() - Subclasses of CrIODevice implement blocking
/ functions for device-specific operations. For example, QProcess
/ has a function called waitForStarted() which suspends operation in
/ the calling thread until the process has started.
/ \\endlist
/
/ Calling these functions from the main, GUI thread, may cause your
/ user interface to freeze. Example:
/
/ \\snippet doc/src/snippets/code/src_corelib_io_qiodevice.cpp 0
/
/ By subclassing CrIODevice, you can provide the same interface to
/ your own I/O devices. Subclasses of CrIODevice are only required to
/ implement the protected readData() and writeData() functions.
/ CrIODevice uses these functions to implement all its convenience
/ functions, such as getChar(), readLine() and write(). CrIODevice
/ also handles access control for you, so you can safely assume that
/ the device is opened in write mode if writeData() is called.
/
/ Some subclasses, such as QFile and QTcpSocket, are implemented
/ using a memory buffer for intermediate storing of data. This
/ reduces the number of required device accessing calls, which are
/ often very slow. Buffering makes functions like getChar() and
/ putChar() fast, as they can operate on the memory buffer instead
/ of directly on the device itself. Certain I/O operations, however,
/ don't work well with a buffer. For example, if several users open
/ the same device and read it character by character, they may end
/ up reading the same data when they meant to read a separate chunk
/ each. For this reason, CrIODevice allows you to bypass any
/ buffering by passing the Unbuffered flag to open(). When
/ subclassing CrIODevice, remember to bypass any buffer you may use
/ when the device is open in Unbuffered mode.
/
/ \\sa QBuffer QFile QTcpSocket
/
/
/
/ \\typedef CrIODevice::Offset
/ \\compat
/
/ Use \\c qint64 instead.
/
/
/
/ \\typedef CrIODevice::Status
/ \\compat
/
/ Use CrIODevice::OpenMode instead, or see the documentation for
/ specific devices.
/
/
/
/ \\enum CrIODevice::OpenModeFlag
/
/ This enum is used with open() to describe the mode in which a device
/ is opened. It is also returned by openMode().
/
/ \\value NotOpen   The device is not open.
/ \\value ReadOnly  The device is open for reading.
/ \\value WriteOnly The device is open for writing.
/ \\value ReadWrite The device is open for reading and writing.
/ \\value Append    The device is opened in append mode, so that all data is
/                  written to the end of the file.
/ \\value Truncate  If possible, the device is truncated before it is opened.
/                  All earlier contents of the device are lost.
/ \\value Text      When reading, the end-of-line terminators are
/                  translated to '\\n'. When writing, the end-of-line
/                  terminators are translated to the local encoding, for
/                  example '\\r\\n' for Win32.
/ \\value Unbuffered Any buffer in the device is bypassed.
/
/ Certain flags, such as \\c Unbuffered and \\c Truncate, are
/ meaningless when used with some subclasses. Some of these
/ restrictions are implied by the type of device that is represented
/ by a subclass. In other cases, the restriction may be due to the
/ implementation, or may be imposed by the underlying platform; for
/ example, QTcpSocket does not support \\c Unbuffered mode, and
/ limitations in the native API prevent QFile from supporting \\c
/ Unbuffered on Windows.
/
/
/     \\fn CrIODevice::bytesWritten(qint64 bytes)
/
/ This signal is emitted every time a payload of data has been
/ written to the device. The \\a bytes argument is set to the number
/ of bytes that were written in this payload.
/
/ bytesWritten() is not emitted recursively; if you reenter the event loop
/ or call waitForBytesWritten() inside a slot connected to the
/ bytesWritten() signal, the signal will not be reemitted (although
/ waitForBytesWritten() may still return true).
/
/ \\sa readyRead()
/
/
/
/ \\fn CrIODevice::readyRead()
/
/ This signal is emitted once every time new data is available for
/ reading from the device. It will only be emitted again once new
/ data is available, such as when a new payload of network data has
/ arrived on your network socket, or when a new block of data has
/ been appended to your device.
/
/ readyRead() is not emitted recursively; if you reenter the event loop or
/ call waitForReadyRead() inside a slot connected to the readyRead() signal,
/ the signal will not be reemitted (although waitForReadyRead() may still
/ return true).
/
/ Note for developers implementing classes derived from CrIODevice:
/ you should always emit readyRead() when new data has arrived (do not
/ emit it only because there's data still to be read in your
/ buffers). Do not emit readyRead() in other conditions.
/
/ \\sa bytesWritten()
/
/
/ \\fn CrIODevice::aboutToClose()
/
/ This signal is emitted when the device is about to close. Connect
/ this signal if you have operations that need to be performed
/ before the device closes (e.g., if you have data in a separate
/ buffer that needs to be written to the device).
/
/
/
/ \\fn CrIODevice::readChannelFinished()
/ \\since 4.4
/
/ This signal is emitted when the input (reading) stream is closed
/ in this device. It is emitted as soon as the closing is detected,
/ which means that there might still be data available for reading
/ with read().
/
/ \\note This class has function names in lowercase for compatibility
/ with QT4.
/
/ \\sa atEnd(), read()
/"
      class 278402 "OpenModeFlag"
	visibility package stereotype "enum"
	cpp_decl "${comment}enum ${name} {
${items}
};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	oid 278402
	comment "! This enum is used with open() to describe the mode in which a device is opened. 
! It is also returned by openMode().
!
! Certain flags, such as Unbuffered and Truncate, are meaningless when used with some subclasses. 
! Some of these restrictions are implied by the type of device that is represented by a subclass. In other 
! cases, the restriction may be due to the implementation, or may be imposed by the underlying 
! platform; for example, QTcpSocket does not support Unbuffered mode, and limitations in the native 
! API prevent QFile from supporting Unbuffered on Windows.
!
! The OpenMode type is a typedef for CrFlags<OpenModeFlag>. It stores an OR combination of 
! OpenModeFlag values."
	attribute 204162 "NotOpen"
	  public type class_ref 278402 // OpenModeFlag
	  init_value " 0x0000"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 204162
	  comment "!< The device is not open."
	end

	attribute 204290 "ReadOnly"
	  public type class_ref 278402 // OpenModeFlag
	  init_value " 0x0001"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 204290
	  comment "!< The device is open for reading."
	end

	attribute 204418 "WriteOnly"
	  public type class_ref 278402 // OpenModeFlag
	  init_value " 0x0002"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 204418
	  comment "!< The device is open for writing."
	end

	attribute 204546 "ReadWrite"
	  public type class_ref 278402 // OpenModeFlag
	  init_value " ReadOnly | WriteOnly"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 204546
	  comment "!<The device is open for reading and writing."
	end

	attribute 204674 "Append"
	  public type class_ref 278402 // OpenModeFlag
	  init_value " 0x0004"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 204674
	  comment "!< The device is opened in append mode, so that all data is written to the end of the file."
	end

	attribute 204802 "Truncate"
	  public type class_ref 278402 // OpenModeFlag
	  init_value " 0x0008"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 204802
	  comment "!< If possible, the device is truncated before it is opened.
!< All earlier contents of the device are lost."
	end

	attribute 204930 "Text"
	  public type class_ref 278402 // OpenModeFlag
	  init_value " 0x0010"
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 204930
	  comment "!< When reading, the end-of-line terminators are translated to '\\n'. 
!< When writing, the end-of-line terminators are translated to the 
!< local encoding, for example '\\r\\n' for Win32.
"
	end

	attribute 205058 "Unbuffered"
	  public type class_ref 278402 // OpenModeFlag
	  init_value " 0x0020
    "
	  cpp_decl "  ${name}${value},${comment}"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  oid 205058
	  comment "!< Any buffer in the device is bypassed."
	end
      end

      extra_member 147842 "CR_DECLARE_FLAGS(OpenMode, OpenModeFlag)"
	
	cpp "    CR_DECLARE_FLAGS(OpenMode, OpenModeFlag)
" ""
	java ""
	php ""
	python ""
	idl ""
	oid 147842
	comment "    //! Declaration of the flags
    //! \\note This macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to 
    //! use CR_ENUMS() in addition to this macro.
"
      end

      class 278530 "Status"
	visibility package stereotype "typedef" explicit_base_type "int"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	oid 278530
      end

      class 285442 "Offset"
	visibility package stereotype "typedef" explicit_base_type "int64_t"
	cpp_decl "${comment}typedef ${type} ${name};
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	oid 285442
      end

      operation 240770 "CrIODevice"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${volatile}${throw}
     : d_ptr(new CrIODevicePrivate()) {
 ${body}}
"
	
	
	
	
	oid 240770
	comment "! Constructs a CrIODevice object. "
      end

      operation 235906 "~CrIODevice"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "//!
//    Constructs a CrIODevice object with the given \\a parent.
//
//!
//  The destructor is virtual, and CrIODevice is an abstract base
//  class. This destructor does not call close(), but the subclass
//  destructor might. If you are in doubt, call close() before
//  destroying the CrIODevice.

${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
	oid 235906
      end

      operation 236034 "openMode"
	preserve_cpp_body_indent const public explicit_return_type "CrIODevice::OpenMode"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns the mode in which the device has been opened;
//    i.e. ReadOnly or WriteOnly.
//
//    \\sa OpenMode

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 236034
	comment "! Returns the mode in which the device has been opened;
! i.e. ReadOnly or WriteOnly.
! \\sa OpenMode"
      end

      operation 236162 "setTextModeEnabled"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "enabled" explicit_type "bool"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    If \\a enabled is true, this function sets the \\l Text flag on the device;
//    otherwise the \\l Text flag is removed. This feature is useful for classes
//    that provide custom end-of-line handling on a CrIODevice.
//
//    \\sa open(), setOpenMode()

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 236162
	comment "! If \\a enabled is true, this function sets the \\l Text flag on the device;
! otherwise the \\l Text flag is removed. This feature is useful for classes
! that provide custom end-of-line handling on a QIODevice.
!
! \\sa open(), setOpenMode()"
      end

      operation 236290 "isTextModeEnabled"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns true if the \\l Text flag is enabled; otherwise returns false.
//
//    \\sa setTextModeEnabled()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 236290
	comment "! Returns true if the \\l Text flag is enabled; otherwise returns false.
!
! \\sa setTextModeEnabled()"
      end

      operation 236418 "isOpen"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns true if the device is open; otherwise returns false. A
//    device is open if it can be read from and/or written to. By
//    default, this function returns false if openMode() returns
//    \\c NotOpen.
//
//    \\sa openMode() OpenMode

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 236418
	comment "! Returns true if the device is open; otherwise returns false. A
! device is open if it can be read from and/or written to. By
! default, this function returns false if openMode() returns
! \\c NotOpen.
!
! \\sa openMode() OpenMode
!"
      end

      operation 236546 "isReadable"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns true if data can be read from the device; otherwise returns
//    false. Use bytesAvailable() to determine how many bytes can be read.
//
//    This is a convenience function which checks if the OpenMode of the
//    device contains the ReadOnly flag.
//
//    \\sa openMode() OpenMode

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 236546
	comment "! Returns true if data can be read from the device; otherwise returns
! false. Use bytesAvailable() to determine how many bytes can be read.
!
! This is a convenience function which checks if the OpenMode of the
! device contains the ReadOnly flag.
!
! \\sa openMode() OpenMode
!"
      end

      operation 236674 "isWritable"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns true if data can be written to the device; otherwise returns
//    false.
//
//    This is a convenience function which checks if the OpenMode of the
//    device contains the WriteOnly flag.
//
//    \\sa openMode() OpenMode

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 236674
	comment "! Returns true if data can be written to the device; otherwise returns
! false.
!
! This is a convenience function which checks if the OpenMode of the
! device contains the WriteOnly flag.
!
! \\sa openMode() OpenMode"
      end

      operation 236802 "isSequential"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns true if this device is sequential; otherwise returns
//    false.
//
//    Sequential devices, as opposed to a random-access devices, have no
//    concept of a start, an end, a size, or a current position, and they
//    do not support seeking. You can only read from the device when it
//    reports that data is available. The most common example of a
//    sequential device is a network socket. On Unix, special files such
//    as /dev/zero and fifo pipes are sequential.
//
//    Regular files, on the other hand, do support random access. They
//    have both a size and a current position, and they also support
//    seeking backwards and forwards in the data stream. Regular files
//    are non-sequential.
//
//    \\sa bytesAvailable()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 236802
      end

      operation 236930 "open"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 1
	  param in name "mode" explicit_type "OpenMode"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Opens the device and sets its OpenMode to \\a mode. Returns true if successful;
//    otherwise returns false. This function should be called from any
//    reimplementations of open() or other functions that open the device.
//
//    \\sa openMode() OpenMode

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 236930
	comment "! Opens the device and sets its OpenMode to \\a mode. Returns true if successful;
! otherwise returns false. This function should be called from any
! reimplementations of open() or other functions that open the device.
!
! \\sa openMode() OpenMode
!"
      end

      operation 237058 "close"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    First emits aboutToClose(), then closes the device and sets its
//    OpenMode to NotOpen. The error string is also reset.
//
//    \\sa setOpenMode() OpenMode

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 237058
	comment "! First emits aboutToClose(), then closes the device and sets its
! OpenMode to NotOpen. The error string is also reset.
!
! \\sa setOpenMode() OpenMode"
      end

      operation 237186 "pos"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "int64_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    For random-access devices, this function returns the position that
//    data is written to or read from. For sequential devices or closed
//    devices, where there is no concept of a \"current position\", 0 is
//    returned.
//
//    The current read/write position of the device is maintained internally by
//    CrIODevice, so reimplementing this function is not necessary. When
//    subclassing CrIODevice, use CrIODevice::seek() to notify CrIODevice about
//    changes in the device position.
//
//    \\sa isSequential(), seek()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 237186
	comment "  For random-access devices, this function returns the position that
 data is written to or read from. For sequential devices or closed
 devices, where there is no concept of a \"current position\", 0 is
 returned.

! The current read/write position of the device is maintained internally by
! CrIODevice, so reimplementing this function is not necessary. When
! subclassing CrIODevice, use CrIODevice::seek() to notify CrIODevice about
! changes in the device position.
!
! \\sa isSequential(), seek()
### Qt 5: pos() and seek() should not be virtual, and
 ### seek() should call a virtual seekData() function."
      end

      operation 237314 "size"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "int64_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    For open random-access devices, this function returns the size of the
//    device. For open sequential devices, bytesAvailable() is returned.
//
//    If the device is closed, the size returned will not reflect the actual
//    size of the device.
//
//    \\sa isSequential(), pos()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 237314
	comment "! For open random-access devices, this function returns the size of the
! device. For open sequential devices, bytesAvailable() is returned.
!
! If the device is closed, the size returned will not reflect the actual
! size of the device.
!
! \\sa isSequential(), pos()"
      end

      operation 237442 "seek"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 1
	  param in name "pos" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    For random-access devices, this function sets the current position
//    to \\a pos, returning true on success, or false if an error occurred.
//    For sequential devices, the default behavior is to do nothing and
//    return false.
//
//    When subclassing CrIODevice, you must call CrIODevice::seek() at the
//    start of your function to ensure integrity with CrIODevice's
//    built-in buffer. The base implementation always returns true.
//
//    \\sa pos(), isSequential()

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 237442
	comment "! For random-access devices, this function sets the current position
! to \\a pos, returning true on success, or false if an error occurred.
! For sequential devices, the default behavior is to do nothing and
! return false.
!
! When subclassing CrIODevice, you must call CrIODevice::seek() at the
! start of your function to ensure integrity with CrIODevice's
! built-in buffer. The base implementation always returns true.
!
! \\sa pos(), isSequential()"
      end

      operation 237570 "atEnd"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns true if the current read and write position is at the end
//    of the device (i.e. there is no more data available for reading on
//    the device); otherwise returns false.
//
//    For some devices, atEnd() can return true even though there is more data
//    to read. This special case only applies to devices that generate data in
//    direct response to you calling read() (e.g., \\c /dev or \\c /proc files on
//    Unix and Mac OS X, or console input / \\c stdin on all platforms).
//
//    \\sa bytesAvailable(), read(), isSequential()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 237570
	comment "! Returns true if the current read and write position is at the end
! of the device (i.e. there is no more data available for reading on
! the device); otherwise returns false.
!
! For some devices, atEnd() can return true even though there is more data
! to read. This special case only applies to devices that generate data in
! direct response to you calling read() (e.g., \\c /dev or \\c /proc files on
! Unix and Mac OS X, or console input / \\c stdin on all platforms).
!
! \\sa bytesAvailable(), read(), isSequential()"
      end

      operation 237698 "reset"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Seeks to the start of input for random-access devices. Returns
//    true on success; otherwise returns false (for example, if the
//    device is not open).
//
//    Note that when using a QTextStream on a QFile, calling reset() on
//    the QFile will not have the expected result because QTextStream
//    buffers the file. Use the QTextStream::seek() function instead.
//
//    \\sa seek()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 237698
	comment "! Seeks to the start of input for random-access devices. Returns
! true on success; otherwise returns false (for example, if the
! device is not open).
!
! Note that when using a QTextStream on a QFile, calling reset() on
! the QFile will not have the expected result because QTextStream
! buffers the file. Use the QTextStream::seek() function instead.
!
! \\sa seek()"
      end

      operation 237826 "bytesAvailable"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "int64_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns the number of bytes that are available for reading. This
//    function is commonly used with sequential devices to determine the
//    number of bytes to allocate in a buffer before reading.
//
//    Subclasses that reimplement this function must call the base
//    implementation in order to include the size of CrIODevices' buffer. Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 1
//
//    \\sa bytesToWrite(), readyRead(), isSequential()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 237826
	comment "! Returns the number of bytes that are available for reading. This
! function is commonly used with sequential devices to determine the
! number of bytes to allocate in a buffer before reading.
!
! Subclasses that reimplement this function must call the base
! implementation in order to include the size of QIODevices' buffer. Example:
!
! \\snippet doc/src/snippets/code/src_corelib_io_qiodevice.cpp 1
!
! \\sa bytesToWrite(), readyRead(), isSequential()"
      end

      operation 237954 "bytesToWrite"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "int64_t"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    For buffered devices, this function returns the number of bytes
//    waiting to be written. For devices with no buffer, this function
//    returns 0.
//
//    \\sa bytesAvailable(), bytesWritten(), isSequential()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 237954
	comment "! For buffered devices, this function returns the number of bytes
! waiting to be written. For devices with no buffer, this function
! returns 0.
!
! \\sa bytesAvailable(), bytesWritten(), isSequential()"
      end

      operation 238338 "readAll"
	preserve_cpp_body_indent public explicit_return_type "std::vector<char>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    \\overload
//
//    Reads all available data from the device, and returns it as a
//    QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 238338
	comment "! \\overload
!
! Reads all available data from the device, and returns it as a
! QByteArray.
!
! This function has no way of reporting errors; returning an empty
! QByteArray() can mean either that no data was currently available
! for reading, or that an error occurred."
      end

      operation 238722 "canReadLine"
	preserve_cpp_body_indent const cpp_virtual public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns true if a complete line of data can be read from the device;
//    otherwise returns false.
//
//    Note that unbuffered devices, which have no way of determining what
//    can be read, always return false.
//
//    This function is often called in conjunction with the readyRead()
//    signal.
//
//    Subclasses that reimplement this function must call the base
//    implementation in order to include the contents of the CrIODevice's buffer. Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 3
//
//    \\sa readyRead(), readLine()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 238722
	comment "! Returns true if a complete line of data can be read from the device;
! otherwise returns false.
!
! Note that unbuffered devices, which have no way of determining what
! can be read, always return false.
!
! This function is often called in conjunction with the readyRead()
! signal.
!
! Subclasses that reimplement this function must call the base
! implementation in order to include the contents of the QIODevice's buffer. Example:
!
! \\snippet doc/src/snippets/code/src_corelib_io_qiodevice.cpp 3
!
! \\sa readyRead(), readLine()"
      end

      operation 238978 "write"
	preserve_cpp_body_indent public explicit_return_type "int64_t"
	nparams 1
	  param in name "data" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    \\since 4.5
//
//    \\overload
//
//    Writes data from a zero-terminated string of 8-bit characters to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred. This is equivalent to
//    \\code
//    ...
//    CrIODevice::write(data, qstrlen(data));
//    ...
//    \\endcode
//
//    \\sa read() writeData()

${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 238978
	comment "! \\since 4.5
!
! \\overload
!
! Writes data from a zero-terminated string of 8-bit characters to the
! device. Returns the number of bytes that were actually written, or
! -1 if an error occurred. This is equivalent to
! \\code
! ...
! CrIODevice::write(data, qstrlen(data));
! ...
! \\endcode
!
! \\sa read() writeData()"
      end

      operation 239106 "write"
	cpp_inline public explicit_return_type "int64_t"
	nparams 1
	  param in name "data" explicit_type "std::vector<char>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return write(data.data(), data.size()); };
"
	
	
	
	
	oid 239106
	comment "! \\overload
!
! Writes the content of \\a std::vector<char> to the device. Returns the number of
! bytes that were actually written, or -1 if an error occurred.
!
! \\sa read() writeData()"
      end

      operation 239490 "waitForReadyRead"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 1
	  param in name "msecs" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Blocks until new data is available for reading and the readyRead()
//    signal has been emitted, or until \\a msecs milliseconds have
//    passed. If msecs is -1, this function will not time out.
//
//    Returns true if new data is available for reading; otherwise returns
//    false (if the operation timed out or if an error occurred).
//
//    This function can operate without an event loop. It is
//    useful when writing non-GUI applications and when performing
//    I/O operations in a non-GUI thread.
//
//    If called from within a slot connected to the readyRead() signal,
//    readyRead() will not be reemitted.
//
//    Reimplement this function to provide a blocking API for a custom
//    device. The default implementation does nothing, and returns false.
//
//    \\warning Calling this function from the main (GUI) thread
//    might cause your user interface to freeze.
//
//    \\sa waitForBytesWritten()

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 239490
	comment "! Blocks until new data is available for reading and the readyRead()
! signal has been emitted, or until \\a msecs milliseconds have
! passed. If msecs is -1, this function will not time out.
!
! Returns true if new data is available for reading; otherwise returns
! false (if the operation timed out or if an error occurred).
!
! This function can operate without an event loop. It is
! useful when writing non-GUI applications and when performing
! I/O operations in a non-GUI thread.
!
! If called from within a slot connected to the readyRead() signal,
! readyRead() will not be reemitted.
!
! Reimplement this function to provide a blocking API for a custom
! device. The default implementation does nothing, and returns false.
!
! \\warning Calling this function from the main (GUI) thread
! might cause your user interface to freeze.
!
! \\sa waitForBytesWritten()"
      end

      operation 239618 "waitForBytesWritten"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "bool"
	nparams 1
	  param in name "msecs" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    For buffered devices, this function waits until a payload of
//    buffered written data has been written to the device and the
//    bytesWritten() signal has been emitted, or until \\a msecs
//    milliseconds have passed. If msecs is -1, this function will
//    not time out. For unbuffered devices, it returns immediately.
//
//    Returns true if a payload of data was written to the device;
//    otherwise returns false (i.e. if the operation timed out, or if an
//    error occurred).
//
//    This function can operate without an event loop. It is
//    useful when writing non-GUI applications and when performing
//    I/O operations in a non-GUI thread.
//
//    If called from within a slot connected to the bytesWritten() signal,
//    bytesWritten() will not be reemitted.
//
//    Reimplement this function to provide a blocking API for a custom
//    device. The default implementation does nothing, and returns false.
//
//    \\warning Calling this function from the main (GUI) thread
//    might cause your user interface to freeze.
//
//    \\sa waitForReadyRead()

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 239618
	comment "! For buffered devices, this function waits until a payload of
! buffered written data has been written to the device and the
! bytesWritten() signal has been emitted, or until \\a msecs
! milliseconds have passed. If msecs is -1, this function will
! not time out. For unbuffered devices, it returns immediately.
!
! Returns true if a payload of data was written to the device;
! otherwise returns false (i.e. if the operation timed out, or if an
! error occurred).
!
! This function can operate without an event loop. It is
! useful when writing non-GUI applications and when performing
! I/O operations in a non-GUI thread.
!
! If called from within a slot connected to the bytesWritten() signal,
! bytesWritten() will not be reemitted.
!
! Reimplement this function to provide a blocking API for a custom
! device. The default implementation does nothing, and returns false.
!
! \\warning Calling this function from the main (GUI) thread
! might cause your user interface to freeze.
!
! \\sa waitForReadyRead()"
      end

      operation 239746 "ungetChar"
	preserve_cpp_body_indent public explicit_return_type "void"
	nparams 1
	  param in name "c" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//! \\fn int64_t CrIODevice::write(const QByteArray &byteArray)
//
//    \\overload
//
//    Writes the content of \\a byteArray to the device. Returns the number of
//    bytes that were actually written, or -1 if an error occurred.
//
//    \\sa read() writeData()
//
//!
//    Puts the character \\a c back into the device, and decrements the
//    current position unless the position is 0. This function is
//    usually called to \"undo\" a getChar() operation, such as when
//    writing a backtracking parser.
//
//    If \\a c was not previously read from the device, the behavior is
//    undefined.

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 239746
	comment "! Puts the character \\a c back into the device, and decrements the
! current position unless the position is 0. This function is
! usually called to \"undo\" a getChar() operation, such as when
! writing a backtracking parser.
!
! If \\a c was not previously read from the device, the behavior is
! undefined."
      end

      operation 239874 "putChar"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 1
	  param in name "c" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//! \\fn bool CrIODevice::putChar(char c)
//
//    Writes the character \\a c to the device. Returns true on success;
//    otherwise returns false.
//
//    \\sa write() getChar() ungetChar()

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 239874
	comment "! Writes the character \\a c to the device. Returns true on success;
! otherwise returns false.
!
! \\sa write() getChar() ungetChar()"
      end

      operation 240002 "getChar"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 1
	  param inout name "c" explicit_type "char"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//! \\fn bool CrIODevice::getChar(char *c)
//
//    Reads one character from the device and stores it in \\a c. If \\a c
//    is 0, the character is discarded. Returns true on success;
//    otherwise returns false.
//
//    \\sa read() putChar() ungetChar()

${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 240002
	comment "! Reads one character from the device and stores it in \\a c. If \\a c
! is 0, the character is discarded. Returns true on success;
! otherwise returns false.
!
! \\sa read() putChar() ungetChar()"
      end

      operation 240130 "errorString"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Returns a human-readable description of the last device error that
//    occurred.
//
//    \\sa setErrorString()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 240130
	comment "! Returns a human-readable description of the last device error that
! occurred.
!
! \\sa setErrorString()"
      end

      operation 240258 "readyRead"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 240258
      end

      operation 240386 "bytesWritten"
	public explicit_return_type "void"
	nparams 1
	  param in name "bytes" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 240386
      end

      operation 240514 "aboutToClose"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 240514
      end

      operation 240642 "readChannelFinished"
	public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 240642
      end

      operation 258818 "CrIODevice"
	preserve_cpp_body_indent protected explicit_return_type ""
	nparams 1
	  param inout name "dd" type class_ref 263938 // CrIODevicePrivate
	cpp_decl "    ${comment}${inline}${name}${(}${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "//! \\internal

${inline}${class}::${name}${(}${t0} & ${p0}${)}
    : d_ptr(&dd)
${throw}{
  ${body}}
"
	
	
	
	
	oid 258818
      end

      operation 241282 "setOpenMode"
	preserve_cpp_body_indent protected explicit_return_type "void"
	nparams 1
	  param in name "openMode" explicit_type "OpenMode"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Sets the OpenMode of the device to \\a openMode. Call this
//    function to set the open mode if the flags change after the device
//    has been opened.
//
//    \\sa openMode() OpenMode

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 241282
	comment "! Sets the OpenMode of the device to \\a openMode. Call this
! function to set the open mode if the flags change after the device
! has been opened.
!
! \\sa openMode() OpenMode
"
      end

      operation 240898 "readData"
	abstract cpp_virtual protected explicit_return_type "int64_t"
	nparams 2
	  param inout name "data" explicit_type "char"
	  param in name "maxlen" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 240898
	comment "! Reads up to \\a maxSize bytes from the device into \\a data, and
! returns the number of bytes read or -1 if an error occurred. If
! there are no bytes to be read, this function should return -1 if
! there can never be more bytes available (for example: socket
! closed, pipe closed, sub-process finished).
!
! This function is called by QIODevice. Reimplement this function
! when creating a subclass of QIODevice.
!
! \\sa read() readLine() writeData()"
      end

      operation 241026 "readLineData"
	preserve_cpp_body_indent cpp_virtual protected explicit_return_type "int64_t"
	nparams 2
	  param inout name "data" explicit_type "char"
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Reads up to \\a maxSize characters into \\a data and returns the
//    number of characters read.
//
//    This function is called by readLine(), and provides its base
//    implementation, using getChar(). Buffered devices can improve the
//    performance of readLine() by reimplementing this function.
//
//    readLine() appends a '\\0' byte to \\a data; readLineData() does not
//    need to do this.
//
//    If you reimplement this function, be careful to return the correct
//    value: it should return the number of bytes read in this line,
//    including the terminating newline, or 0 if there is no line to be
//    read at this point. If an error occurs, it should return -1 if and
//    only if no bytes were read. Reading past EOF is considered an error.

${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 241026
	comment "! Reads up to \\a maxSize characters into \\a data and returns the
! number of characters read.
!
! This function is called by readLine(), and provides its base
! implementation, using getChar(). Buffered devices can improve the
! performance of readLine() by reimplementing this function.
!
! readLine() appends a '\\0' byte to \\a data; readLineData() does not
! need to do this.
!
! If you reimplement this function, be careful to return the correct
! value: it should return the number of bytes read in this line,
! including the terminating newline, or 0 if there is no line to be
! read at this point. If an error occurs, it should return -1 if and
! only if no bytes were read. Reading past EOF is considered an error."
      end

      operation 241154 "writeData"
	abstract cpp_virtual protected explicit_return_type "int64_t"
	nparams 2
	  param in name "data" explicit_type "char"
	  param in name "len" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 241154
	comment "! Writes up to \\a maxSize bytes from \\a data to the device. Returns
! the number of bytes written, or -1 if an error occurred.
!
! This function is called by QIODevice. Reimplement this function
! when creating a subclass of QIODevice.
!
! \\sa read() write()"
      end

      operation 241410 "setErrorString"
	preserve_cpp_body_indent protected explicit_return_type "void"
	nparams 1
	  param in name "str" explicit_type "string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Sets the human readable description of the last device error that
//    occurred to \\a str.
//
//    \\sa errorString()

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 241410
	comment "! Sets the human readable description of the last device error that
! occurred to \\a str.
!
! \\sa errorString()"
      end

      classrelation 216578 // d_ptr (<directional composition>)
	relation 216578 *-->
	  stereotype "auto_ptr"
	  oid 216578
	  a role_name "d_ptr" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 216578 // d_ptr (<directional composition>)
	  b parent class_ref 263938 // CrIODevicePrivate
	oid 216578
      end

      operation 241538 "flags"
	const cpp_inline public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return static_cast<int>(openMode()); };
"
	
	
	
	
	oid 241538
	comment "! Use openMode() instead."
      end

      operation 241666 "mode"
	const cpp_inline public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return static_cast<int>(openMode()); };
"
	
	
	
	
	oid 241666
	comment "! Use openMode() instead."
      end

      operation 241794 "state"
	preserve_cpp_body_indent const cpp_inline public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 241794
	comment "! Use isOpen() instead."
      end

      operation 241922 "isDirectAccess"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return !isSequential(); };
"
	
	
	
	
	oid 241922
	comment "! Use !isSequential() instead."
      end

      operation 242050 "isSequentialAccess"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return isSequential(); };
"
	
	
	
	
	oid 242050
	comment "! Use isSequential() instead."
      end

      operation 242178 "isCombinedAccess"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return false; };
"
	
	
	
	
	oid 242178
	comment "! Use openMode() instead."
      end

      operation 242306 "isBuffered"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return true; };
"
	
	
	
	
	oid 242306
      end

      operation 242434 "isRaw"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return false; };
"
	
	
	
	
	oid 242434
	comment "! Use openMode() instead."
      end

      operation 242562 "isSynchronous"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return true; };
"
	
	
	
	
	oid 242562
	comment "! This functionality is no longer available. This function always
! returns false."
      end

      operation 242690 "isAsynchronous"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return false; };
"
	
	
	
	
	oid 242690
	comment "! This functionality is no longer available. This function always
! returns true."
      end

      operation 242818 "isTranslated"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return (openMode() & Text) != 0; };
"
	
	
	
	
	oid 242818
	comment "! Use openMode() instead."
      end

      operation 242946 "isInactive"
	const cpp_inline public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return !isOpen(); };
"
	
	
	
	
	oid 242946
	comment "! Use isOpen(), isReadable(), or isWritable() instead."
      end

      operation 243202 "at"
	const cpp_inline public return_type class_ref 285442 // Offset
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { return pos(); };
"
	
	
	
	
	oid 243202
	comment "! Use pos() instead.  "
      end

      operation 258946 "at"
	cpp_inline public explicit_return_type "bool"
	nparams 1
	  param in name "offset" type class_ref 285442 // Offset
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return seek(offset); };
"
	
	
	
	
	oid 258946
	comment "! Use seek(\\a offset) instead."
      end

      operation 259074 "readBlock"
	cpp_inline public explicit_return_type "int64_t"
	nparams 2
	  param inout name "data" explicit_type "char"
	  param in name "maxlen" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${)}${const}${volatile}${throw}${abstract} { return read(data, maxlen); };
"
	
	
	
	
	oid 259074
	comment "! Use read(\\a data, \\a size) instead."
      end

      operation 259202 "writeBlock"
	cpp_inline public explicit_return_type "int64_t"
	nparams 2
	  param in name "data" explicit_type "char"
	  param in name "len" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${abstract} { return write(data, len); };
"
	
	
	
	
	oid 259202
	comment "! Use write(\\a data, \\a size) instead."
      end

      operation 259330 "writeBlock"
	cpp_inline public explicit_return_type "int64_t"
	nparams 1
	  param in name "data" explicit_type "std::vector<char>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return write(data); };
"
	
	
	
	
	oid 259330
	comment "! Use write(\\a data) instead."
      end

      operation 243330 "getch"
	cpp_inline public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} { char c; return getChar(&c) ? int(unsigned char(c)) : -1; };
"
	
	
	
	
	oid 243330
	comment "! Use getChar() instead."
      end

      operation 243458 "putch"
	cpp_inline public explicit_return_type "int"
	nparams 1
	  param in name "c" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return putChar(char(c)) ? int(unsigned char(c)) : -1; };
"
	
	
	
	
	oid 243458
	comment "! Use putChar(\\a ch) instead."
      end

      operation 243586 "ungetch"
	cpp_inline public explicit_return_type "int"
	nparams 1
	  param in name "c" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { ungetChar(unsigned char(c)); return c; };
"
	
	
	
	
	oid 243586
	comment "! Use ungetChar(\\a ch) instead."
      end

      operation 238082 "read"
	preserve_cpp_body_indent public explicit_return_type "int64_t"
	nparams 2
	  param inout name "data" explicit_type "char"
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()
//!
//    Reads at most \\a maxSize bytes from the device into \\a data, and
//    returns the number of bytes read. If an error occurs, such as when
//    attempting to read from a device opened in WriteOnly mode, this
//    function returns -1.
//
//    0 is returned when no more data is available for reading. However,
//    reading past the end of the stream is considered an error, so this
//    function returns -1 in those cases (that is, reading on a closed
//    socket or after a process has died).
//
//    \\sa readData() readLine() write()

${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 238082
	comment "! Reads at most \\a maxSize bytes from the device into \\a data, and
! returns the number of bytes read. If an error occurs, such as when
! attempting to read from a device opened in WriteOnly mode, this
! function returns -1.
!
! 0 is returned when no more data is available for reading. However,
! reading past the end of the stream is considered an error, so this
! function returns -1 in those cases (that is, reading on a closed
! socket or after a process has died).
!
! \\sa readData() readLine() write()"
      end

      operation 238210 "read"
	preserve_cpp_body_indent public explicit_return_type "std::vector<char>"
	nparams 1
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads at most \\a maxSize bytes from the device, and returns the
//    data read as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 238210
	comment "! \\overload
!
! Reads at most \\a maxSize bytes from the device, and returns the
! data read as a QByteArray.
!
! This function has no way of reporting errors; returning an empty
! QByteArray() can mean either that no data was currently available
! for reading, or that an error occurred."
      end

      operation 238466 "readLine"
	preserve_cpp_body_indent public explicit_return_type "int64_t"
	nparams 2
	  param inout name "data" explicit_type "char"
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()
//!
//    This function reads a line of ASCII characters from the device, up
//    to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
//    data, and returns the number of bytes read. If a line could not be
//    read but no error ocurred, this function returns 0. If an error
//    occurs, this function returns the length of what could be read, or
//    -1 if nothing was read.
//
//    A terminating '\\0' byte is always appended to \\a data, so \\a
//    maxSize must be larger than 1.
//
//    Data is read until either of the following conditions are met:
//
//    \\list
//    \\o The first '\\n' character is read.
//    \\o \\a maxSize - 1 bytes are read.
//    \\o The end of the device data is detected.
//    \\endlist
//
//    For example, the following code reads a line of characters from a
//    file:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 2
//
//    The newline character ('\\n') is included in the buffer. If a
//    newline is not encountered before maxSize - 1 bytes are read, a
//    newline will not be inserted into the buffer. On windows newline
//    characters are replaced with '\\n'.
//
//    This function calls readLineData(), which is implemented using
//    repeated calls to getChar(). You can provide a more efficient
//    implementation by reimplementing readLineData() in your own
//    subclass.
//
//    \\sa getChar(), read(), write()

${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 238466
	comment "! This function reads a line of ASCII characters from the device, up
! to a maximum of \\a maxSize - 1 bytes, stores the characters in \\a
! data, and returns the number of bytes read. If a line could not be
! read but no error ocurred, this function returns 0. If an error
! occurs, this function returns the length of what could be read, or
! -1 if nothing was read.
!
! A terminating '\\0' byte is always appended to \\a data, so \\a
! maxSize must be larger than 1.
!
! Data is read until either of the following conditions are met:
!
! \\list
! \\o The first '\\n' character is read.
! \\o \\a maxSize - 1 bytes are read.
! \\o The end of the device data is detected.
! \\endlist
!
! For example, the following code reads a line of characters from a
! file:
!
! \\snippet doc/src/snippets/code/src_corelib_io_qiodevice.cpp 2
!
! The newline character ('\\n') is included in the buffer. If a
! newline is not encountered before maxSize - 1 bytes are read, a
! newline will not be inserted into the buffer. On windows newline
! characters are replaced with '\\n'.
!
! This function calls readLineData(), which is implemented using
! repeated calls to getChar(). You can provide a more efficient
! implementation by reimplementing readLineData() in your own
! subclass.
!
! \\sa getChar(), read(), write()"
      end

      operation 238594 "readLine"
	preserve_cpp_body_indent public explicit_return_type "std::vector<char>"
	nparams 1
	  param in name "maxSize" explicit_type "int64_t"
	    defaultvalue "0"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.
//!
//    \\overload
//
//    Reads a line from the device, but no more than \\a maxSize characters,
//    and returns the result as a QByteArray.
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for reading, or that an error occurred.

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 238594
	comment "! \\overload
!
! Reads a line from the device, but no more than \\a maxSize characters,
! and returns the result as a QByteArray.
!
! This function has no way of reporting errors; returning an empty
! QByteArray() can mean either that no data was currently available
! for reading, or that an error occurred."
      end

      operation 238850 "write"
	preserve_cpp_body_indent public explicit_return_type "int64_t"
	nparams 2
	  param in name "data" explicit_type "char"
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()
//!
//    Writes at most \\a maxSize bytes of data from \\a data to the
//    device. Returns the number of bytes that were actually written, or
//    -1 if an error occurred.
//
//    \\sa read() writeData()

${inline}${type} ${class}::${name}${(}const ${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 238850
	comment "! Writes at most \\a maxSize bytes of data from \\a data to the
! device. Returns the number of bytes that were actually written, or
! -1 if an error occurred.
!
! \\sa read() writeData()"
      end

      operation 239234 "peek"
	preserve_cpp_body_indent public explicit_return_type "int64_t"
	nparams 2
	  param inout name "data" explicit_type "char"
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()
//!
//    \\since 4.1
//
//    Reads at most \\a maxSize bytes from the device into \\a data, without side
//    effects (i.e., if you call read() after peek(), you will get the same
//    data).  Returns the number of bytes read. If an error occurs, such as
//    when attempting to peek a device opened in WriteOnly mode, this function
//    returns -1.
//
//    0 is returned when no more data is available for reading.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 4
//
//    \\sa read()

${inline}${type} ${class}::${name}${(}${t0} * ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 239234
	comment "! Reads at most \\a maxSize bytes from the device into \\a data, without side
! effects (i.e., if you call read() after peek(), you will get the same
! data).  Returns the number of bytes read. If an error occurs, such as
! when attempting to peek a device opened in WriteOnly mode, this function
! returns -1.
!
! 0 is returned when no more data is available for reading.
!
! Example:
!
! \\snippet doc/src/snippets/code/src_corelib_io_qiodevice.cpp 4
!
! \\sa read()"
      end

      operation 239362 "peek"
	preserve_cpp_body_indent public explicit_return_type "std::vector<char>"
	nparams 1
	  param in name "maxSize" explicit_type "int64_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()
//!
//    \\since 4.1
//    \\overload
//
//    Peeks at most \\a maxSize bytes from the device, returning the data peeked
//    as a QByteArray.
//
//    Example:
//
//    \\snippet doc/src/snippets/code/src_corelib_io_CrIOdevice.cpp 5
//
//    This function has no way of reporting errors; returning an empty
//    QByteArray() can mean either that no data was currently available
//    for peeking, or that an error occurred.
//
//    \\sa read()

${inline}${type} ${class}::${name}${(}${t0} ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 239362
	comment "! \\overload
!
! Peeks at most \\a maxSize bytes from the device, returning the data peeked
! as a QByteArray.
!
! Example:
!
! \\snippet doc/src/snippets/code/src_corelib_io_qiodevice.cpp 5
!
! This function has no way of reporting errors; returning an empty
! QByteArray() can mean either that no data was currently available
! for peeking, or that an error occurred.
!
! \\sa read()"
      end

      operation 243074 "resetStatus"
	preserve_cpp_body_indent private explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()
//!
//    For device specific error handling, please refer to the
//    individual device documentation.
//
//    \\sa qobject_cast()

${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 243074
	comment "! For device specific error handling, please refer to the
! individual device documentation.
!
! \\sa qobject_cast()"
      end

      operation 259714 "d_func"
	cpp_inline private return_type class_ref 263938 // CrIODevicePrivate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type}* ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type}* ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 259714
      end

      operation 259842 "d_func"
	const cpp_inline private return_type class_ref 263938 // CrIODevicePrivate
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type}* ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}const ${type}* ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 259842
      end

      classrelation 223362 // <dependency>
	relation 223362 -_->
	  stereotype "friend"
	  oid 223362
	  a private
	    cpp default "${type}"
	    classrelation_ref 223362 // <dependency>
	  b parent class_ref 263938 // CrIODevicePrivate
	oid 223362
      end
    end

    class 285570 "CrIODeviceQT3"
      visibility package 
      cpp_decl "${comment}${template}class PLATFORM_DECL ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 285570
      comment " Q_DECLARE_OPERATORS_FOR_FLAGS(CrIODevice::OpenMode)"
      attribute 215042 "IO_Direct"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0x0100"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 215042
      end

      attribute 215170 "IO_Sequential"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0x0200"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 215170
      end

      attribute 215298 "IO_Combined"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0x0300"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 215298
      end

      attribute 215426 "IO_TypeMask"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0x0300"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 215426
      end

      attribute 215554 "IO_Raw"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0x0000"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 215554
      end

      attribute 215682 "IO_Async"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0x0000"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 215682
      end

      attribute 215810 "IO_Open"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0x1000"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 215810
      end

      attribute 215938 "IO_StateMask"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0xf000"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 215938
      end

      attribute 216066 "IO_Ok"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  0"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 216066
      end

      attribute 216194 "IO_ReadError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  1"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 216194
      end

      attribute 216322 "IO_WriteError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  2"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 216322
      end

      attribute 216450 "IO_FatalError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  3"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 216450
      end

      attribute 216578 "IO_ResourceError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  4"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 216578
      end

      attribute 216706 "IO_OpenError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  5"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 216706
      end

      attribute 216834 "IO_ConnectError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  5"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 216834
      end

      attribute 216962 "IO_AbortError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  6"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 216962
      end

      attribute 217090 "IO_TimeOutError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  7"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 217090
      end

      attribute 217218 "IO_UnspecifiedError"
	class_attribute const_attribute public explicit_type "uint"
	init_value "=  8"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	oid 217218
      end
    end

    classdiagram 193410 "CrZipFilePrivate"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      oid 193410
      size A4
    end

    classdiagram 193538 "CrZipPrivate"
      draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
      oid 193538
      size A4
    end

    class 312194 "CrRar"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      oid 312194
      comment "!ZIP archive.
!\\class CrZip CrZip.h <quazip/quazip.h>
! This class implements basic interface to the ZIP archive. It can be
! used to read table contents of the ZIP archive and retreiving
! information about the files inside it.
!
! You can also use this class to open files inside archive by passing
! pointer to the instance of this class to the constructor of the
! CrZipFile class. But see CrZipFile::CrZipFile(CrZip*, QObject*)
! for the possible pitfalls.
!
! This class is indended to provide interface to the ZIP subpackage of
! the ZIP/UNZIP package as well as to the UNZIP subpackage. But
! currently it supports only UNZIP.
!
! The use of this class is simple - just create instance using
! constructor, then set ZIP archive file name using setFile() function
! (if you did not passed the name to the constructor), then open() and
! then use different functions to work with it! Well, if you are
! paranoid, you may also wish to call close before destructing the
! instance, to check for errors on close.
!
! You may also use getUnzFile() and getZipFile() functions to get the
! ZIP archive handle and use it with ZIP/UNZIP package API directly.
!
! This class supports localized file names inside ZIP archive, but you
! have to set up proper codec with setCodec() function. By default,
! locale codec will be used, which is probably ok for UNIX systems, but
! will almost certainly fail with ZIP archives created in Windows. This
! is because Windows ZIP programs have strange habit of using DOS
! encoding for file names in ZIP archives. For example, ZIP archive
! with cyrillic names created in Windows will have file names in \\c
! IBM866 encoding instead of \\c WINDOWS-1251. I think that calling one
! function is not much trouble, but for true platform independency it
! would be nice to have some mechanism for file name encoding auto
! detection using locale information. Does anyone know a good way to do
! it?"
      classrelation 250114 // <generalisation>
	relation 250114 ---|>
	  oid 250114
	  a public
	    cpp default "${type}"
	    classrelation_ref 250114 // <generalisation>
	  b parent class_ref 298754 // CrZipBase
	oid 250114
      end

      classrelation 249986 // <dependency>
	relation 249986 -_->
	  stereotype "friend"
	  oid 249986
	  a default
	    cpp default "${type}"
	    classrelation_ref 249986 // <dependency>
	  b parent class_ref 236034 // CrZipPrivate
	oid 249986
      end

      operation 296578 "CrRar"
	private explicit_return_type ""
	nparams 1
	  param in name "that" type class_ref 312194 // CrRar
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw};
"
	
	
	
	
	oid 296578
	comment "! not (and will not be) implemented"
      end

      operation 296706 "operator ="
	private return_type class_ref 312194 // CrRar
	nparams 1
	  param in name "that" type class_ref 312194 // CrRar
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} & ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	
	
	
	
	oid 296706
	comment "! not (and will not be) implemented"
      end

      operation 296834 "CrRar"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw};
"
	cpp_def "//*
// * / Constructs CrZip object.
// * * Call setName() before opening constructed object.

${inline}${class}::${name}${(}${)}:
  CrZipBase()
${throw}{
  ${body}}
"
	
	
	
	
	oid 296834
	comment "! Constructs CrZip object.
! Call setName() before opening constructed object. "
      end

      operation 296962 "CrRar"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param in name "zipName" explicit_type "string"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} ${p0}${)}:
  CrZipBase(${p0})
${throw}{
  ${body}}
"
	
	
	
	
	oid 296962
	comment "! Constructs CrZip object associated with ZIP file \\a zipName."
      end

      operation 297090 "CrRar"
	preserve_cpp_body_indent public explicit_return_type ""
	nparams 1
	  param inout name "ioDevice" type class_ref 278274 // CrIODevice
	cpp_decl "    ${comment}${inline}${name}${(}${t0} & ${p0}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${t0} & ${p0}${)}:
  CrZipBase(${p0})
${throw}{
  ${body}}
"
	
	
	
	
	oid 297090
	comment "! Constructs CrZip object associated with ZIP file represented by \\a ioDevice.
! The IO device must be seekable, otherwise an error will occur when opening. "
      end

      operation 297218 "~CrRar"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw};
"
	cpp_def "${comment}${inline}${class}::${name}${(}${)}${throw}{
  ${body}}
"
	
	
	
	
	oid 297218
	comment "! Destroys CrZip object.
! Calls close() if necessary. "
      end

      operation 297346 "open"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 2
	  param in name "mode" type class_ref 236930 // Mode
	  param inout name "ioApi_" explicit_type "void"
	    defaultvalue "NULL"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} * ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 297346
	comment "! Opens ZIP file.
!
! Argument \\a mode specifies open mode of the ZIP archive. See Mode
! for details. Note that there is zipOpen2() function in the
! ZIP/UNZIP API which accepts \\a globalcomment argument, but it
! does not use it anywhere, so this open() function does not have this
! argument. See setComment() if you need to set global comment.
!
! If the ZIP file is accessed via explicitly set QIODevice, then
! this device is opened in the necessary mode. If the device was
! already opened by some other means, then the behaviour is defined by
! the device implementation, but generally it is not a very good
! idea. For example, QFile will at least issue a warning.
!
! \\return \\c true if successful, \\c false otherwise.
!
! \\note ZIP/UNZIP API open calls do not return error code - they
! just return \\c NULL indicating an error. But to make things
! easier, CrZip.h header defines additional error code \\c
! UNZ_ERROROPEN and getZipError() will return it if the open call
! of the ZIP/UNZIP API returns \\c NULL.
!
! Argument \\a ioApi specifies IO function set for ZIP/UNZIP
! package to use. See unzip.h, zip.h and ioapi.h for details. Note
! that IO API for CrZip is different from the original package.
! The file path argument was changed to be of type \\c voidpf, and
! CrZip passes a QIODevice pointer there. This QIODevice is either
! set explicitly via setIoDevice() or the CrZip(QIODevice*)
! constructor, or it is created internally when opening the archive
! by its file name. The default API (qioapi.cpp) just delegates
! everything to the QIODevice API. Not only this allows to use a
! QIODevice instead of file name, but also has a nice side effect
! of raising the file size limit from 2G to 4G.
!
! In short: just forget about the \\a ioApi argument and you'll be
! fine."
      end

      operation 297474 "close"
	preserve_cpp_body_indent cpp_virtual public explicit_return_type "void"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 297474
	comment "! Closes ZIP file.
! Call getZipError() to determine if the close was successful. The
! underlying QIODevice is also closed, regardless of whether it was
! set explicitly or not. "
      end

      operation 297602 "getEntriesCount"
	preserve_cpp_body_indent const public explicit_return_type "int"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 297602
	comment "! Returns number of the entries in the ZIP central directory.
! Returns negative error code in the case of error. The same error
! code will be returned by subsequent getZipError() call."
      end

      operation 297730 "getComment"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 297730
	comment "! Returns global comment in the ZIP file."
      end

      operation 297858 "goToFirstFile"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 297858
	comment "! Sets the current file to the first file in the archive.
! Returns \\c true on success, \\c false otherwise. Call
!   getZipError() to get the error code."
      end

      operation 297986 "goToNextFile"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 297986
	comment "! Sets the current file to the next file in the archive.
! Returns \\c true on success, \\c false otherwise. Call
!  getZipError() to determine if there was an error.
!
!  Should be used only in CrZip::mdUnzip mode.

  \\note If the end of file was reached, getZipError() will return
  \\c UNZ_OK instead of \\c UNZ_END_OF_LIST_OF_FILE. This is to make
  things like this easier:
  \\code
  for(bool more=zip.goToFirstFile(); more; more=zip.goToNextFile()) {
    // do something
  }
  if(zip.getZipError()==UNZ_OK) {
    // ok, there was no error
  }
  \\endcode"
      end

      operation 298114 "setCurrentFile"
	preserve_cpp_body_indent public explicit_return_type "bool"
	nparams 2
	  param in name "fileName" explicit_type "string"
	  param in name "cs" type class_ref 237058 // CaseSensitivity
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 298114
	comment "! Sets current file by its name.
! Returns \\c true if successful, \\c false otherwise. Argument \\a
!  cs specifies case sensitivity of the file name. Call
!  getZipError() in the case of a failure to get error code.
!
!  This is not a wrapper to unzLocateFile() function. That is
!  because I had to implement locale-specific case-insensitive
!  comparison.
!
!  Here are the differences from the original implementation:
!
!  - If the file was not found, error code is \\c UNZ_OK, not \\c
!    UNZ_END_OF_LIST_OF_FILE (see also goToNextFile()).
!  - If this function fails, it unsets the current file rather than
!    resetting it back to what it was before the call.
!
!  If \\a fileName is null string then this function unsets the
!  current file and return \\c true. Note that you should close the
!  file first if it is open! See
!  CrZipFile::CrZipFile(CrZip*,QObject*) for the details.
!
!  Should be used only in CrZip::mdUnzip mode.
!
!  \\sa setFileNameCodec(), CaseSensitivity"
      end

      operation 298242 "getCurrentFileInfo"
	preserve_cpp_body_indent const public explicit_return_type "bool"
	nparams 1
	  param inout name "info" type class_ref 243586 // CrZipFileInfo
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${t0} * ${p0}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 298242
	comment "! Retrieves information about the current file.
! Fills the structure pointed by \\a info. Returns \\c true on
!  success, \\c false otherwise. In the latter case structure pointed
!  by \\a info remains untouched. If there was an error,
!  getZipError() returns error code.
!
!  Should be used only in CrZip::mdUnzip mode.
!
!  Does nothing and returns \\c false in any of the following cases.
!  - ZIP is not open;
!  - ZIP does not have current file;
!  - \\a info is \\c NULL;
!
!  In all these cases getZipError() returns \\c UNZ_OK since there
!  is no ZIP/UNZIP API call."
      end

      operation 298370 "getCurrentFileName"
	preserve_cpp_body_indent const public explicit_return_type "string"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract};
"
	cpp_def "${comment}${inline}${type} ${class}::${name}${(}${)}${const}${volatile}${throw}${staticnl}{
  ${body}}
"
	
	
	
	
	oid 298370
	comment "! Returns the current file name.
! Equivalent to calling getCurrentFileInfo() and then getting \\c
!  name field of the CrZipFileInfo structure, but faster and more
!  convenient.
!
!  Should be used only in CrZip::mdUnzip mode."
      end
    end
  end

  deploymentview 167298 "CrZip"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    oid 167298
    artifact 227074 "CrZipBase"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
${namespace_start}

// just in case it will be defined in the later versions of the ZIP/UNZIP
#ifndef UNZ_OPENERROR
// define additional error code
#define UNZ_OPENERROR -1000
#endif

// Make an uppercase copy of s
std::string upperCase(const std::string& s) {
    std::string upper(s);
    for(size_t i = 0; i < s.length(); ++i)
        upper[i] = toupper(upper[i]);
    return upper;
}

// Make a lowercase copy of s
std::string lowerCase(const std::string& s) {
    std::string lower(s);
    for(size_t i = 0; i < s.length(); ++i)
        lower[i] = tolower(lower[i]);
    return lower;
}

${members}
${namespace_end}"
      associated_classes
	class_ref 250242 // QTextCodec
	class_ref 298754 // CrZipBase
      end
      oid 227074
    end

    artifact 187522 "CrZip"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
#include \"Crunchy/CrZipPrivate.h\"
#include \"Crunchy/shared/Txt.h\"
#include \"minizip/zip.h\"
#include \"minizip/unzip.h\"

// just in case it will be defined in the later versions of the ZIP/UNZIP
#ifndef UNZ_OPENERROR
// define additional error code
#define UNZ_OPENERROR -1000
#endif

${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 236674 // CrZip
      end
      oid 187522
    end

    artifact 194050 "CrZipPrivate"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
${includes}
#include \"minizip/zip.h\"
#include \"minizip/unzip.h\"
${declarations}
${namespace_start}
${definition}
${namespace_end}
#include \"CrZipPrivate.cpp\"
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 236034 // CrZipPrivate
      end
      oid 194050
    end

    artifact 194178 "CrZipFileInfo"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
#include <cstdint>
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 243586 // CrZipFileInfo
      end
      oid 194178
    end

    artifact 200706 "CrZipFile"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
#include <cstdint>
${includes}
#include \"minizip/zip.h\"
#include \"minizip/unzip.h\"
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 256770 // CrZipFile
      end
      oid 200706
    end

    artifact 207234 "CrZipFilePrivate"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
#include <cstdint>
#include \"Crunchy/CrZip.h\"
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#include \"CrZipFilePrivate.cpp\"
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 257026 // CrZipFilePrivate
      end
      oid 207234
    end

    artifact 207362 "CrIODevicePrivate"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
#include \"Crunchy/CrIODevice.h\"
#include \"Crunchy/shared/Helpers.h\"

#include <cstdint>
${includes}

#ifndef CRIODEVICE_BUFFERSIZE
#define CRIODEVICE_BUFFERSIZE CR_INT64_C(16384)
#endif

${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 263682 // CrIODevicePrivateLinearBuffer
	class_ref 263938 // CrIODevicePrivate
      end
      oid 207362
    end

    artifact 213890 "CrIODevice"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
#include \"Crunchy/shared/Helpers.h\"
${includes}

#ifdef open
#error qiodevice.h must be included before any header file that defines open
#endif

${declarations}
${namespace_start}
${definition}

CR_DECLARE_OPERATORS_FOR_FLAGS(CrIODevice::OpenMode)

${namespace_end}
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}

#define Q_VOID

#define CHECK_MAXLEN(function, returnType) \\
    do { \\
        if (maxSize < 0) { \\
            qWarning(\"CrIODevice::\"#function\": Called with maxSize < 0\"); \\
            return returnType; \\
        } \\
    } while (0)

#define CHECK_WRITABLE(function, returnType) \\
   do { \\
       if ((d->openMode & WriteOnly) == 0) { \\
           if (d->openMode == NotOpen) \\
               return returnType; \\
           qWarning(\"CrIODevice::\"#function\": ReadOnly device\"); \\
           return returnType; \\
       } \\
   } while (0)

#define CHECK_READABLE(function, returnType) \\
   do { \\
       if ((d->openMode & ReadOnly) == 0) { \\
           if (d->openMode == NotOpen) \\
               return returnType; \\
           qWarning(\"CrIODevice::\"#function\": WriteOnly device\"); \\
           return returnType; \\
       } \\
   } while (0)

${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 278274 // CrIODevice
      end
      oid 213890
    end

    artifact 220546 "CrZipNewInfo"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
#include <cstdint>
#include \"minizip/zip.h\"
#include \"minizip/unzip.h\"
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 292226 // CrZipNewInfo
      end
      oid 220546
    end

    artifact 240130 "CrRar"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
#include \"Crunchy/global.h\"
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
#include \"Crunchy/stdafx.h\"
${includes}
#include \"Crunchy/CrZipPrivate.h\"
#include \"Crunchy/shared/Txt.h\"
#include \"minizip/zip.h\"
#include \"minizip/unzip.h\"

// just in case it will be defined in the later versions of the ZIP/UNZIP
#ifndef UNZ_OPENERROR
// define additional error code
#define UNZ_OPENERROR -1000
#endif

${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 312194 // CrRar
      end
      oid 240130
    end
  end
end
